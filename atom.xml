<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yan Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yansaid.github.io/"/>
  <updated>2017-04-25T04:26:21.000Z</updated>
  <id>https://yansaid.github.io/</id>
  
  <author>
    <name>Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome To Yan&#39;s Website!</title>
    <link href="https://yansaid.github.io/2222/02/22/Me/"/>
    <id>https://yansaid.github.io/2222/02/22/Me/</id>
    <published>2222-02-21T16:00:00.000Z</published>
    <updated>2017-04-25T04:26:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<script>
let urls = [
'http://onk403mwf.bkt.clouddn.com/%E9%99%AA%E6%88%91%E7%9C%8B%E6%97%A5%E5%87%BA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%82%A3%E5%B9%B4%E6%98%A5%E5%A4%A9%E4%B8%8B%E7%9D%80%E9%9B%AA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%9C%80%E8%A6%81%E4%BA%BA%E9%99%AA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%82%A3%E5%B0%B1%E8%BF%99%E6%A0%B7%E5%90%A7.m4a',
'http://onk403mwf.bkt.clouddn.com/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC.mp4',
'http://onk403mwf.bkt.clouddn.com/%E7%88%B1%E6%83%85%E5%BA%9F%E6%9F%B4.m4a'
];
var index = parseInt(Math.random() * (urls.length - 1), 10);
myAudio = document.createElement("audio");
loadAudioAtIndex(index);
function loadAudioAtIndex(index) {
  myAudio.src = urls[index];
  myAudio.loop=false;
  myAudio.play();
}
myAudio.onended = function()
{
  if (index == urls.length - 1) index = -1;
  loadAudioAtIndex(++index);
};
</script>

<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Songs&lt;br&gt;
    
    </summary>
    
      <category term="introduce" scheme="https://yansaid.github.io/categories/introduce/"/>
    
    
      <category term="essay" scheme="https://yansaid.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 实现排序算法</title>
    <link href="https://yansaid.github.io/2017/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://yansaid.github.io/2017/05/11/排序算法/</id>
    <published>2017-05-10T16:00:00.000Z</published>
    <updated>2017-05-11T07:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>当数据量很大的时候, 可以清晰的看出 快速排序的优势。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">// 冒泡排序 优化</div><div class="line"></div><div class="line">- (NSArray *)bubbleBetter:(NSMutableArray *)a &#123;</div><div class="line">    if (a.count &lt;= 1) return [a copy];</div><div class="line">    BOOL flag = true;</div><div class="line">    for (int i = 0; i &lt; a.count - 1; i++) &#123;</div><div class="line">        if (!flag) &#123;</div><div class="line">            return [a copy];</div><div class="line">        &#125;</div><div class="line">        flag = false;</div><div class="line">        for (NSInteger j = 1; j &lt; a.count - i; j++) &#123;</div><div class="line">            if ([a[j - 1] integerValue] &gt; [a[j] integerValue]) &#123;</div><div class="line">                [a exchangeObjectAtIndex:j - 1 withObjectAtIndex:j];</div><div class="line">                flag = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return [a copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 冒泡排序</div><div class="line">- (NSArray *)bubble:(NSMutableArray *)a &#123;</div><div class="line">    if (a.count &lt;= 1) return [a copy];</div><div class="line">    for (int i = 0; i &lt; a.count; i++) &#123;</div><div class="line">        for (int j = i + 1; j &lt; a.count; j++) &#123;</div><div class="line">            if ([a[i] integerValue] &gt; [a[j] integerValue]) &#123;</div><div class="line">                [a exchangeObjectAtIndex:i withObjectAtIndex:j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return [a copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 选择排序</div><div class="line">- (NSArray *)selector:(NSMutableArray *)a &#123;</div><div class="line">    if (a.count &lt;= 1) return [a copy];</div><div class="line">    NSInteger count = a.count;</div><div class="line">    for (int i = 0; i &lt; a.count / 2; i++) &#123;</div><div class="line">        NSInteger min = i;</div><div class="line">        NSInteger max = i;</div><div class="line">        for (int j = i + 1; j &lt; count - i; j++) &#123;</div><div class="line">            if ([a[j] integerValue] &lt; [a[min] integerValue]) &#123;</div><div class="line">                min = j;</div><div class="line">            &#125; else if ([a[j] integerValue] &gt; [a[max] integerValue]) &#123;</div><div class="line">                max = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        [a exchangeObjectAtIndex:i withObjectAtIndex:min];</div><div class="line">        [a exchangeObjectAtIndex:count - i - 1 withObjectAtIndex:max];</div><div class="line">    &#125;</div><div class="line">    return [a copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 快速排序</div><div class="line">- (NSArray *)quick:(NSMutableArray *)a min:(NSInteger)min max:(NSInteger)max &#123;</div><div class="line">    if (a.count &lt;= 1) return [a copy];</div><div class="line">    if (max - min &lt;= 0) return [a copy];</div><div class="line">    NSInteger centerIndex = (max - min) / 2 + min;</div><div class="line">    NSInteger center = [a[centerIndex] integerValue];</div><div class="line">    NSInteger moveTimes = 0;</div><div class="line">    for (NSInteger i = min; i &lt; max; i++) &#123;</div><div class="line">        if (i == centerIndex) &#123;</div><div class="line">            i += moveTimes;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (i &lt; centerIndex) &#123;</div><div class="line">            if ([a[i] integerValue] &gt; center) &#123;</div><div class="line">                id temp = a[i];</div><div class="line">                [a insertObject:temp atIndex:centerIndex + 1];</div><div class="line">                [a removeObjectAtIndex:i];</div><div class="line">                centerIndex--;</div><div class="line">                i--;</div><div class="line">                moveTimes++;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if ([a[i] integerValue] &lt; center) &#123;</div><div class="line">                id temp = a[i];</div><div class="line">                [a insertObject:temp atIndex:centerIndex];</div><div class="line">                [a removeObjectAtIndex:i + 1];</div><div class="line">                centerIndex++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    [self quick:a min:min max:centerIndex];</div><div class="line">    [self quick:a min:centerIndex + 1 max:max];</div><div class="line">    return [a copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当数据量很大的时候, 可以清晰的看出 快速排序的优势。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 解耦</title>
    <link href="https://yansaid.github.io/2017/05/09/uitableview%20%E8%A7%A3%E8%80%A6/"/>
    <id>https://yansaid.github.io/2017/05/09/uitableview 解耦/</id>
    <published>2017-05-08T16:00:00.000Z</published>
    <updated>2017-05-09T04:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>产品开发的时候无法避免的就是在一个 <code>UITableView</code>中, 包含多种样式的 <code>cell</code>, 我们通常的做法如下:<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (indexPath.row == 0) &#123;</div><div class="line">      </div><div class="line">&#125; else if (indexPath.row == 1) &#123;</div><div class="line"></div><div class="line">&#125; else if (indexPath.row == 2) &#123;</div><div class="line"></div><div class="line">&#125; .....</div></pre></td></tr></table></figure>
<p>这样的做法没有问题, 但是如果有很多种 <code>cell</code> 的话, 例如资料页, 当需要在第二和第三个 <code>cell</code> 之间插入一个 <code>cell</code> 的时候, 我们需要把数组添加一列, 然后把整个 <code>if</code> 改一遍, 如何避免 <code>index</code> 之间的耦合? </p>
<p>OK, 简单来说就是在<code>数据模型</code> 中添加一个标识, 数据的排列交给数组, 我们不判断当前是第几个, 只根据标识来确定放那种样式的<code>cell</code>,<br>这样只有当增加新的样式的时候才会涉及到改 UI 部分的代码, 大部分情况我们只需要对数组进行排序即可, 而不必因为该数组, 从而再改 <code>if</code>.</p>
<p>###下面来介绍一款专门为了解耦而写的第三方: <a href="https://github.com/yansaid/HYTableViewSection" target="_blank" rel="external">HYTableViewSection</a></p>
<p>使用方法:<br><code>pod &#39;HYTableViewSection&#39;</code></p>
<p>通过构建数据来实现布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">HYTableViewRow *row = [HYTableViewRow row:@&#123;@&quot;title&quot;:@&quot;style1&quot;&#125;];</div><div class="line">row.identifier = @&quot;style1&quot;;</div><div class="line">row.heightBlock = ^CGFloat&#123;</div><div class="line">    return 100;  // heightBlock 可以使用计算复杂高度, 或者直接使用 row.height</div><div class="line">&#125;;</div><div class="line">[self.tableView.hy_section addRowModel:row atSection:0];</div><div class="line"></div><div class="line">HYTableViewRow *row1 = [HYTableViewRow row:@&#123;@&quot;title&quot;:@&quot;style2&quot;&#125;];</div><div class="line">row1.identifier = @&quot;style2&quot;;</div><div class="line">row1.heightBlock = ^CGFloat&#123;</div><div class="line">    return 150;</div><div class="line">&#125;;</div><div class="line">[self.tableView.hy_section addRowModel:row1 atSection:0];</div><div class="line"></div><div class="line"></div><div class="line">HYTableViewRow *row2 = [HYTableViewRow row:@&#123;@&quot;title&quot;:@&quot;style3&quot;&#125;];</div><div class="line">row2.identifier = @&quot;style3&quot;;</div><div class="line">row2.heightBlock = ^CGFloat&#123;</div><div class="line">    return 80;</div><div class="line">&#125;;</div><div class="line">[self.tableView.hy_section addRowModel:row2 atSection:1];</div></pre></td></tr></table></figure>
<p>代理方法中使用技巧, 除了新增 <code>style</code> 几乎不会涉及改 <code>UITableView</code> 的代理方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    HYTableViewRow *row = [self.tableView.hy_section modelAtIndexPath:indexPath];</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:row.identifier];</div><div class="line">    if (!cell) &#123;</div><div class="line">        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:row.identifier];</div><div class="line">    &#125;</div><div class="line">    cell.textLabel.text = row.model[@&quot;title&quot;];</div><div class="line">    if ([row.identifier isEqualToString:@&quot;style1&quot;]) &#123;</div><div class="line">        cell.contentView.backgroundColor = [UIColor redColor];</div><div class="line">    &#125; else if ([row.identifier isEqualToString:@&quot;style2&quot;]) &#123;</div><div class="line">        cell.contentView.backgroundColor = [UIColor greenColor];</div><div class="line">    &#125; else if ([row.identifier isEqualToString:@&quot;style3&quot;]) &#123;</div><div class="line">        cell.contentView.backgroundColor = [UIColor blueColor];</div><div class="line">    &#125;</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    HYTableViewRow *row = [self.tableView.hy_section modelAtIndexPath:indexPath];</div><div class="line">    return row.height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return [self.tableView.hy_section numberOfRowsInSection:section];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class="line">    return [self.tableView.hy_section numberOfSections];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;产品开发的时候无法避免的就是在一个 &lt;code&gt;UITableView&lt;/code&gt;中, 包含多种样式的 &lt;code&gt;cell&lt;/code&gt;, 我们通常的做法如下:&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Tagged Pointer, weak string 不释放.</title>
    <link href="https://yansaid.github.io/2017/04/25/Tagged%20Pointer/"/>
    <id>https://yansaid.github.io/2017/04/25/Tagged Pointer/</id>
    <published>2017-04-24T16:00:00.000Z</published>
    <updated>2017-04-25T07:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近被 NSString 无法释放这件事搞得糊涂。<br>首先说一下，发现问题的过程：<br><a id="more"></a></p>
<p>有两个 weak properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, weak) id a;</div><div class="line">@property (nonatomic, weak) id sa;</div></pre></td></tr></table></figure></p>
<p>按道理来说, 当一个对象初始化就赋给了一个 weak 对象, 这个对象就会立刻被释放掉, 但有一个特俗的情况, 看下面的代码和输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        NSString *temp = @&quot;sa&quot;;</div><div class="line">        NSMutableString *sa = [[NSMutableString alloc] initWithString:temp];</div><div class="line">        NSMutableArray *array = [NSMutableArray arrayWithObject:@&quot;aaa&quot;];</div><div class="line">        self.a = [array copy];</div><div class="line">        self.sa = [sa copy];</div><div class="line">        NSLog(@&quot;array:%p&quot;, array);</div><div class="line">        NSLog(@&quot;self.a:%p&quot;, self.a);</div><div class="line">        NSLog(@&quot;self.sa:%p&quot;, self.sa);</div><div class="line">        NSLog(@&quot;temp:%p&quot;, temp);</div><div class="line">&#125;</div><div class="line">array:0x600000241ad0</div><div class="line">self.a:0x0</div><div class="line">self.sa:0xa000000000061732</div><div class="line">temp:0x1081d0030</div></pre></td></tr></table></figure>
<p>为什么 self.sa 没有被释放?<br>到这里我们来引入 <a href="https://mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="external"><code>Tagged Pointer</code></a> 这个概念.</p>
<p>对于那些所需内存小于60位的字符串，它可以创建一个Tagged Pointer。其余的则被放置在真正的NSString对象里。这使得常用的短字符串的性能得到明显的提升。<br>NSNumber、NSDate等, 都是使用  <a href="https://mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="external"><code>Tagged Pointer</code></a>.</p>
<p>当你重复运行的时候, 发现 self.sa 的地址, 始终没有发生变化, 其实那并不是对象的地址, 而是直接指向数据的指针.</p>
<p>可以发现实际的地址 <code>self.sa:0xa000000000061732</code> 对应的数据格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0x2 - Length (2)</div><div class="line">0x73 - &apos;s&apos; </div><div class="line">0x61 - &apos;a&apos;</div></pre></td></tr></table></figure></p>
<p>当我改代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        NSString *temp = @&quot;saaaaaaaaaaa&quot;;</div><div class="line">        NSMutableString *sa = [[NSMutableString alloc] initWithString:temp];</div><div class="line">        NSMutableArray *array = [NSMutableArray arrayWithObject:@&quot;aaa&quot;];</div><div class="line">        self.a = [array copy];</div><div class="line">        self.sa = [sa copy];</div><div class="line">        NSLog(@&quot;array:%p&quot;, array);</div><div class="line">        NSLog(@&quot;self.a:%p&quot;, self.a);</div><div class="line">        NSLog(@&quot;self.sa:%p&quot;, self.sa);</div><div class="line">        NSLog(@&quot;temp:%p&quot;, temp);</div><div class="line">        </div><div class="line">&#125;</div><div class="line">array:0x600000055300</div><div class="line">self.a:0x0</div><div class="line">self.sa:0x0</div><div class="line">temp:0x109c74030</div></pre></td></tr></table></figure></p>
<p>发现 self.sa 也变为 nil 了, 因为当长度大于60的时候,  <a href="https://mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="external"><code>Tagged Pointer</code></a>失效, 改用对象存储, 则初始化后立刻被释放掉了.</p>
<p>感谢 <a href="http://stackoverflow.com/users/431526/sven" target="_blank" rel="external">@sven</a> 在 <a href="http://stackoverflow.com/questions/43568704/when-a-weak-object-nsmutablestring-copy-who-holds-the-nsmutablestring-copy" target="_blank" rel="external">stackoverflow</a> 的解答.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被 NSString 无法释放这件事搞得糊涂。&lt;br&gt;首先说一下，发现问题的过程：&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>NSString 为什么用 copy ? Block 为什么用 copy?</title>
    <link href="https://yansaid.github.io/2017/04/10/copy/"/>
    <id>https://yansaid.github.io/2017/04/10/copy/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-10T08:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>copy<br>深拷贝与浅拷贝的区别, 在于是否开辟新内存，copy 只针对堆内存对象而言。</p>
<p>浅拷贝：<br>拷贝的是地址，和对象的 = 赋值是一样的。<br>OC 中 我们声明一个 NSString 属性。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property NSString *str；</div></pre></td></tr></table></figure></p>
<p>为什么会有这个<em>, c 语言中, </em>是一个取值操作符, <em>str 对应的是值, 所以 str 是</em> str 的地址, 为什么要说这个那, 就是 = 传递的是对象的地址, 浅拷贝就是地址的拷贝.</p>
<p>提示：上面提到的只针对堆内存的对象。<br>&amp; 取址操作符，平常声明的值对象是存在栈内存中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int a = 5;</div></pre></td></tr></table></figure></p>
<p>a 对应的栈中存放的 5，&amp;a 对应栈内存地址。</p>
<p>#####深拷贝：<br>开辟新的内存空间，相当于声明了一个新的对象，对象中的值，与当前对象值相同。</p>
<p>NSString 为什么用 copy ?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSString *strongStr;</div><div class="line">@property (nonatomic, copy) NSString *cpyStr;</div></pre></td></tr></table></figure></p>
<p>我们有两个对象, 一个用 strong, 一个用 copy.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSString *tmpStr = @&quot;temp&quot;;</div><div class="line">self.strongStr = tmpStr;</div><div class="line">self.cpyStr = tmpStr;</div><div class="line"></div><div class="line">2017-04-10 12:06:11.953 Copy[66625:4617737] tmpStr:temp</div><div class="line">strongStr:temp</div><div class="line">cpyStr:temp</div><div class="line">2017-04-10 12:06:11.953 Copy[66625:4617737] tmpStr:0x10f096078</div><div class="line">strongStr:0x10f096078</div><div class="line">cpyStr:0x10f096078</div></pre></td></tr></table></figure></p>
<p>对于不可变字符串, copy 和 strong 都是浅拷贝.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSMutableString *tmpStr = [[NSMutableString alloc] initWithString:@&quot;temp&quot;];</div><div class="line">self.strongStr = tmpStr;</div><div class="line">self.cpyStr = tmpStr;</div><div class="line">[tmpStr appendString:@&quot; + add&quot;];</div><div class="line">NSLog(@&quot;tmpStr:%@\n strongStr:%@\n cpyStr:%@&quot;, tmpStr, self.strongStr, self.cpyStr);</div><div class="line">NSLog(@&quot;tmpStr:%p\n strongStr:%p\n cpyStr:%p&quot;, tmpStr, self.strongStr, self.cpyStr);</div><div class="line"></div><div class="line">2017-04-10 11:58:56.888 Copy[66562:4610424] </div><div class="line">tmpStr:temp + add</div><div class="line">strongStr:temp + add</div><div class="line">cpyStr:temp</div><div class="line">2017-04-10 11:58:56.888 Copy[66562:4610424] tmpStr:0x600000271580</div><div class="line">strongStr:0x600000271580</div><div class="line">cpyStr:0xa000000706d65744</div></pre></td></tr></table></figure>
<p>当 tmpStr 改变之后 strongStr 也改变了, 虽然 strongStr 是个不可变字符串, 但是它指向了一个可变字符串. 可以看见 cpyStr 是深拷贝, 它指向的内存和 tmpStr 完全不同.</p>
<p>NSMutableString 不可以使用 copy.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSMutableString *mutableString;</div></pre></td></tr></table></figure></p>
<p>copy 返回的都是不可变的, 所以当执行 <code>appendString:</code> 等NSMutableString特有的方法的时候, 会报<code>unrecognized selector sent to instance</code> 这个错误.</p>
<p>tips:<br>为什么 NSString 可以直接指向一个常量, 而 NSMutableString 不可以?<br>不可变字符串, 不可变, 他可以指向一个常量, 常量是不可变的, 存放在常量区.</p>
<p>Block 为什么用 copy?<br>代码块 是存在栈区的, 需要通过 copy 拷贝到堆内存, ARC 下, 赋值的时候编译器会自行对 block 进行 copy 操作, copy 到堆内存, 与一般的对象是相同的.<br>所以在 ARC 下 block 使用 copy 和 strong 是没有区别的.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;copy&lt;br&gt;深拷贝与浅拷贝的区别, 在于是否开辟新内存，copy 只针对堆内存对象而言。&lt;/p&gt;
&lt;p&gt;浅拷贝：&lt;br&gt;拷贝的是地址，和对象的 = 赋值是一样的。&lt;br&gt;OC 中 我们声明一个 NSString 属性。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>runtime 动态添加方法与执行</title>
    <link href="https://yansaid.github.io/2017/04/10/swizziling/"/>
    <id>https://yansaid.github.io/2017/04/10/swizziling/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-12T07:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>OC 是一门动态的语言, runtime 的机制给开发者提供了许多新的可能, 在运行时, 可以动态为一个类添加方法和属性.<br><a id="more"></a><br>objc_msgSend 执行方法<br>现在我们有一个 Doctor 类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//  Doctor.m</div><div class="line">@implementation Doctor</div><div class="line"></div><div class="line">- (void)sayhello &#123;</div><div class="line">    NSLog(@&quot;hello&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>我们都知道不在.h 里面申明, .只在 .m 中实现的方法, 就相当于私有方法. 但并非绝对的私有.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Doctor *doctor = [[Doctor alloc] init];</div><div class="line">#pragma clang diagnostic push </div><div class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class="line">[doctor performSelector:NSSelectorFromString(@&quot;sayhello&quot;) withObject:nil];</div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure>
<p>使用 perfromSelector 就可以直接掉用知道名字的方法.</p>
<p>perfromSelector相当于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Doctor *doctor = [[Doctor alloc] init];</div><div class="line">SEL sel = NSSelectorFromString(@&quot;sayhello&quot;);</div><div class="line">void (*sendMsg)(id, SEL) = (void (*)(id, SEL))objc_msgSend;</div><div class="line">sendMsg(doctor, sel);</div></pre></td></tr></table></figure></p>
<p>runtime 中使用 objc_msgSend 来执行所有的方法. </p>
<p>class_addMethod 动态添加方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SEL sel = NSSelectorFromString(@&quot;sayhello&quot;);</div><div class="line">// 获取当前类 method</div><div class="line">Method method = class_getInstanceMethod([self class], NSSelectorFromString(@&quot;sayhello&quot;));</div><div class="line">// 让 Doctor 指向当前类的 method</div><div class="line">class_addMethod([doctor class], sel, method_getImplementation(method), method_getTypeEncoding(method));</div><div class="line"></div><div class="line">//当前类声明一个方法</div><div class="line">- (void)sayhello &#123;</div><div class="line">NSLog(@&quot;hello&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Method Swizzling<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@implementation UIViewController (Tracking)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    Class class = [self class];</div><div class="line"></div><div class="line">    SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">    SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class="line"></div><div class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line"></div><div class="line">    // 将 originalMethod 指向 xxx_viewWillAppear: 的实现.</div><div class="line">    BOOL didAddMethod = </div><div class="line">    class_addMethod(class,</div><div class="line">    originalSelector,</div><div class="line">    method_getImplementation(swizzledMethod),</div><div class="line">    method_getTypeEncoding(swizzledMethod));</div><div class="line"></div><div class="line">    if (didAddMethod) &#123;</div><div class="line">            // 将 swizzledMethod 指向 viewWillAppear: 的实现.</div><div class="line">            class_replaceMethod(class,</div><div class="line">            swizzledSelector,</div><div class="line">            method_getImplementation(originalMethod),</div><div class="line">            method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method Swizzling</div><div class="line"></div><div class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self xxx_viewWillAppear:animated]; // 这里实际执行的是 viewWillAppear:</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过调换两个方法的实现, 来实现, 捕捉原始方法的执行. 当需要捕捉某个方法执行, 一种方法是通过继承来实现, 另一种方法通过 Method Swizzling, 当有很多不同形态的子类存在的时候, 继承还是需要写很多重复代码.</p>
<p><a href="http://nshipster.cn/method-swizzling/" target="_blank" rel="external">Method Swizzling @Mattt Thompson</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC 是一门动态的语言, runtime 的机制给开发者提供了许多新的可能, 在运行时, 可以动态为一个类添加方法和属性.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>整洁的代码 - 适配器模式(Adaptor)</title>
    <link href="https://yansaid.github.io/2017/04/10/adaptor/"/>
    <id>https://yansaid.github.io/2017/04/10/adaptor/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-13T09:08:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是适配器模式?<br>例: 我们现在有很多不同种的螺母, 但只有一个螺钉, 螺钉都需要经过处理之后才可以用在螺母上, 处理螺钉的工具就叫做适配器。<br><a id="more"></a></p>
<p>日常开发中，经常遇到多个视图上需要呈现来自一处的数据, 每个视图的数据处理，就可以定义适配器, 对数据进行处理, 每个适配器对数据处理, 返回给对应的视图, 当然使用一个类来包含所有适配器是可以的, 但是如果过多的处理堆在一个类中, 不方便日后阅读, 所以我建议, 每个适配器都建一个类.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 声明 Adaptor</div><div class="line">@property (nonatomic, strong) id&lt;AdaptorProtocol&gt; adaptor;</div><div class="line"></div><div class="line">// 获取数据</div><div class="line">#pragma mark - APIManagerDelegate</div><div class="line">- (void)apiManagerDidSuccess:(APIManager *)manager &#123;</div><div class="line">    NSDictionary *datas = [manager fetchDataWithAdaptor:self.adaptor]; // 通知数据源, 提供数据给 Adaptor 并让 Adaptor 执行数据处理, 返回数据.</div><div class="line">    NSLog(@&quot;%@&quot;, datas);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 初始化</div><div class="line">- (id&lt;AdaptorProtocol&gt;)adaptor &#123;</div><div class="line">    if (!_adaptor) &#123;</div><div class="line">        _adaptor = [[Adaptor alloc] init];</div><div class="line">    &#125;</div><div class="line">    return _adaptor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 数据源 统一处理执行 Adaptor 的方法, 数据源不管你需要什么数据, 只把自己持有的数据给 Adaptor, 让 Adaptor 处理数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// APIManager.m</div><div class="line">- (NSDictionary *)fetchDataWithAdaptor:(id&lt;AdaptorProtocol&gt;)adaptor &#123;</div><div class="line">    if (adaptor == nil) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125; else &#123;</div><div class="line">        return [adaptor configDataWithManager:self]; // 执行数据处理</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//  Adaptor.h</div><div class="line">#import &quot;APIManager.h&quot;</div><div class="line"></div><div class="line">extern NSString * const kAdaptorKeyGender;</div><div class="line">extern NSString * const kAdaptorKeyName;</div><div class="line"></div><div class="line">@interface Adaptor : NSObject&lt;AdaptorProtocol&gt;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//  Adaptor.m</div><div class="line">#import &quot;Adaptor.h&quot;</div><div class="line"></div><div class="line">NSString * const kAdaptorKeyGender = @&quot;kAdaptorKeyGender&quot;;</div><div class="line">NSString * const kAdaptorKeyName = @&quot;kAdaptorKeyName&quot;;</div><div class="line"></div><div class="line">@implementation Adaptor</div><div class="line"></div><div class="line">- (NSDictionary *)configDataWithManager:(APIManager *)manager &#123;</div><div class="line">// 处理数据, 并返回数据</div><div class="line">    return @&#123;kAdaptorKeyName:manager.dic[@&quot;name&quot;], kAdaptorKeyGender:manager.dic[@&quot;gender&quot;]&#125;;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果需要一种新的数据格式, 就可以增加一个新的 Adaptor, 来做相应的处理即可.</p>
<p>使用适配模式, 主要是为了把数据处理从 view 中抽出来, 方便日后的测试和修改.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是适配器模式?&lt;br&gt;例: 我们现在有很多不同种的螺母, 但只有一个螺钉, 螺钉都需要经过处理之后才可以用在螺母上, 处理螺钉的工具就叫做适配器。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>__attribute__((cleanup(function))</title>
    <link href="https://yansaid.github.io/2016/10/28/attribute%E4%BD%BF%E7%94%A8/"/>
    <id>https://yansaid.github.io/2016/10/28/attribute使用/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2017-04-05T01:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>__attribute__</code> 是一个编译命令, 可以为变量、函数、类型定义提供一些属性.<br><code>__attribute__</code>有很多属性deprecated、unused、cleanup等等， 本文主要讲 cleanup.<br><a id="more"></a><br>cleanup 变量作用域结束之前, 走 cleanup 方法.</p>
<p>基本功能:<br>变量作用域结束之前, 执行cleanup指定的方法,方法的参数为变量的地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-9139f7951f968b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-698d86c538b7a3cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面是, 当 block 作用域结束的时候让 cleanup 执行的具体实现.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static void cleanBlock(__strong void(^*block)(void))  &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if DEBUG</div><div class="line">#define keywordify autoreleasepool &#123;&#125;</div><div class="line">#else</div><div class="line">#define keywordify try &#123;&#125; @catch (...) &#123;&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">#define onExit \</div><div class="line">keywordify \</div><div class="line">__strong void(^block)(void) __attribute__((cleanup(cleanBlock), unused)) = ^</div></pre></td></tr></table></figure></p>
<p><code>keywordify</code> 的作用就是在使用的时候可以在前面加一个@, 可以防止 return-type warning, 使用<code>autoreleasepool</code>的时候会创建一个没有实际意义的自动释放池.<br>所以使用<code>@try/@catch/@finally</code>来实现前面加@.</p>
<p>具体可参考 ReactiveCocoa2.5 版本 “RACmetamacros.h”.</p>
<p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        NSLock *lock = [[NSLock alloc] init];</div><div class="line">        [lock lock];</div><div class="line">        @onExit &#123;</div><div class="line">            [lock unlock];</div><div class="line">            NSLog(@&quot;end&quot;);</div><div class="line">        &#125;;</div><div class="line">        sleep(5);</div><div class="line">        NSLog(@&quot;begin&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log:begin</div><div class="line">log:end</div></pre></td></tr></table></figure>
<p>onExit 主要的作用是在某个块执行结束, 自动执行 block, 避免了忘记 unlock.</p>
<p>如果想让代码在{}最后执行都可以使用 onExit.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 是一个编译命令, 可以为变量、函数、类型定义提供一些属性.&lt;br&gt;&lt;code&gt;__attribute__&lt;/code&gt;有很多属性deprecated、unused、cleanup等等， 本文主要讲 cleanup.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>objective-c 的消息转发</title>
    <link href="https://yansaid.github.io/2016/07/15/objective-c%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>https://yansaid.github.io/2016/07/15/objective-c消息转发/</id>
    <published>2016-07-14T16:00:00.000Z</published>
    <updated>2017-04-05T01:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>objc 在执行一个方法的时候是如何判断一个方法是否存在的?</p>
<a id="more"></a>
<ol>
<li>从本类和父类中查找.</li>
<li>检查是否动态添加方法.</li>
<li>查看是否存在快速消息转发.</li>
<li>查看标准消息转发.</li>
</ol>
<p>1-4是按照顺序进行的, 若在某个环节查到符合的方法, 下面的查找则终止.</p>
<ol>
<li>我就不具体解释了.</li>
<li><p>objc 是一门动态的语言, 它允许在运行时, 向一个类添加属性、方法等. class_addMethod、class_addIvar、class_addProperty、class_addProtocol. 具体使用就不介绍了. 需要重写 resolveInstanceMethod 方法, 在其中判断需要添加的方法, 使用class_addMethod来动态添加方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+(BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    if(aSEL == @selector(methodName))&#123;</div><div class="line">        class_addMethod(Class cls, SEL name, IMP imp,</div><div class="line">        const char *types) ;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NSObject 提供快速消息转发方法, 只要重新</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>之后, 每次在父类本类中找不到, 并且没有找到动态添加方法, 则会走该方法, 你可以在这个方法中, return 目标对象, 则目标对象执行 aSelector. 如果没有重写标准消息转发, 并且 return nil, 则会报 <code>unrecognized selector sent to instance</code> 这个错误.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    Person *person = [[Person alloc]init];</div><div class="line">        if ([person respondsToSelector:aSelector]) &#123;</div><div class="line">        return person;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.标准消息转发, 主要可以实现多对象同时转发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 生成一个方法, 并存入表中</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    if (!signature) &#123;</div><div class="line">        signature = [yourObj methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    return signature; // 将一个新签名的方法放入表中</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现动态添加方法, 并执行方法</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    SEL seletor = [anInvocation selector];</div><div class="line">    if ([yourObj respondsToSelector:seletor]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:yourObj];</div><div class="line">    &#125;</div><div class="line">    // 这里可以转发若干个你想转发的对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方法的 invoke 大概应该是这样实现的</div><div class="line">// 相当于 class_addMethod, 将 yourObj 中的方法  IMP 给了[self class].</div><div class="line">- (void) invokeWithTarget:(id)target &#123;</div><div class="line">    Method method = class_getInstanceMethod([target class], aSelector);</div><div class="line">    class_addMethod([self class],</div><div class="line">    aSelector,</div><div class="line">    method_getImplementation(method),</div><div class="line">    method_getTypeEncoding(method));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;objc 在执行一个方法的时候是如何判断一个方法是否存在的?&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>一个react native 的第三方, 附 npm 发布教程.</title>
    <link href="https://yansaid.github.io/2016/06/30/tipsView/"/>
    <id>https://yansaid.github.io/2016/06/30/tipsView/</id>
    <published>2016-06-29T16:00:00.000Z</published>
    <updated>2017-05-09T04:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个我日常开发所使用的工具, 会在日后不断在 GitHub 上更新.<br>目前提供手写板的功能和截图的功能.<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/2131368-62683a0f099fd8d8.gif?imageMogr2/auto-orient/strip" alt=""><br>使用: npm i –save react-native-tipsview</p>
<p>具体使用请看demo: <a href="https://github.com/yansaid/RNTipsView/tree/master/Example" target="_blank" rel="external">https://github.com/yansaid/RNTipsView/tree/master/Example</a><br>运行 demo: 下载代码, 进入 Example/tips,<br>nmp install<br>进入 ios 工程直接运行项目即可, 目前仅支持 iOS.</p>
<p>npm 发布流程:</p>
<ol>
<li><p>首先注册npm 账号:<br><a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a>,免费的即可.</p>
</li>
<li><p>生成 package.json :<br>npm 上面的信息都包含在 package.json 文件中.<br>首先在控制台进入想要发布的 package 目录,<br>然后在控制台输入 npm init , 此时正在配置 package.json 文件.<br>配置信息包括很多.<br>name : 唯一标示, 必须全部为小写, npm i –save<code>react-native-tipsview</code>中, <code>react-native-tipsview</code>就是name.<br>version : 版本号.<br>description : 描述信息, 你查看发布后的包的描述就可以看见.<br>main : 入口文件.<br>keywords : 关键词, 主要用于搜索时.</p>
</li>
</ol>
<p>还有很多配置信息可自行搜索学习, 例如 GitHub 等等, 其中 name, 和 version 是必要字段, 没有则无法发布.</p>
<ol>
<li>发布<br><code>npm publish --registry http://registry.npmjs.org</code></li>
</ol>
<p>等待发布完毕, 可以尝试使用一下.</p>
<p>GitHub: <a href="https://github.com/yansaid/RNTipsView" target="_blank" rel="external">https://github.com/yansaid/RNTipsView</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个我日常开发所使用的工具, 会在日后不断在 GitHub 上更新.&lt;br&gt;目前提供手写板的功能和截图的功能.&lt;br&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://yansaid.github.io/categories/React-Native/"/>
    
    
      <category term="react native" scheme="https://yansaid.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>__strong、__weak、__block.</title>
    <link href="https://yansaid.github.io/2016/05/03/block/"/>
    <id>https://yansaid.github.io/2016/05/03/block/</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2017-04-14T02:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下循环引用, 为什么没用<code>__weak</code> 修饰就直接用 <code>self.</code>属性不会造成循环引用.<br>循环引用是指两个或者多个对象循环持有造成的无法释放.<br><a id="more"></a><br>类 <code>Person</code> 有个属性 <code>block</code>, 在 <code>block</code> 实现后, 此时 <code>self</code> 持有 <code>block</code>, 如果在 <code>block</code> 中, 直接使用 <code>self</code>, <code>block</code> 将持有 <code>self</code>, 造成循环引用, 如果 <code>block</code> 本身不是 <code>self</code> 的属性, 则 <code>self</code>不持有 <code>block</code>, 即使在 <code>block</code> 中直接使用 <code>self</code> 也不会造成循环引用, 但是为了避免多个对象的循环引用, 所以 <code>block</code> 中最好还是用<code>__weak</code>, 防止这种情况出现. 代理用 <code>weak</code> 与此同理.</p>
<p>__block:<br>使外部变量可以在 <code>Block</code> 内部进行修改.<br><img src="http://upload-images.jianshu.io/upload_images/2131368-4b64251e2b00e4a3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-d2d3f4e1e2394432?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>输出:<br>num:2, pointer:0xb000000000000022<br>blockNum:3, pointer:0xb000000000000032<br>可见 <strong> block 会拷贝原来对象,  </strong>block修饰的对象可被 Block 内外同时修改.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-2547ebf5885ccbef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可见 <code>doctor</code> 和 <code>self</code> 被 <code>block</code> 持有, 即使没有使用<code>__ block</code> 修饰,但他们的属性依然可以被修改, 不会像上面的 <code>num = @3;</code> 那样报错禁止修改, 和 <code>NSArray</code> 是一样的, <code>NSArray</code> 本身是不可修改的, 但是 NSArray 里面存放的对象依然是可以修改的.</p>
<p>__weak:<br><img src="http://upload-images.jianshu.io/upload_images/2131368-ed78fc9023d519ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2131368-b1c3b8f30a523dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>weak</code>的实现,  将当前对象(= 右边的对象)值的地址存入 <code>weak hash</code> 表, <code>hash</code> 表中的 <code>key</code> 是 <code>weak</code> 对象的地址, <code>value</code> 是当前对象(= 右边的对象)值的地址, 当每次访问<code>weak</code> 对象的时候, 首先找到 <code>key</code>, 再找到 <code>value</code>. 当当前对象的值被释放, <code>weak hash</code> 表将 <code>value</code> 设置为<code>nil</code>.  如果理解不了, 可以看一下 C语言的指针, 指针的指针. </p>
<p> __weak 的作用: <code>weak</code> 表中的指向的对象, 不计入引用计数. 不持有对象, 但可以引用对象, 不参与对象释放.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-188aa742ee71c5f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2131368-252e85de5c25330e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可见被<code>__weak</code> 修饰过的对象, 不会被 <code>block</code> 持有,所以在对象释放的时候, <code>block</code> 中的 <code>weak</code> 对象也被置为 <code>nil</code>.</p>
<p>但有一种特殊的情况,  就是存放在栈区的对象并不会因为引用对象的释放而释放.<br><img src="http://upload-images.jianshu.io/upload_images/2131368-5cb84159fe6dd19a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-b23a175a0bfa213a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>字符串常量是存在栈区的, 栈内存并不会动态释放, 而是当当前线程执行完毕后, 释放当前线程的栈内存. 所有的常量都存在栈区.<br>所以上面的例子中即使使用<code>__ weak</code> 修饰, 但是<code>@&quot;aa&quot;</code>这个常量并没有被释放, 所以 <code>weak</code>的地址指向依然存在值.</p>
<p><strong>strong:<br>在某个块内对当前对象引用计数加一.<br>在 AFN 中经常出现 <code>block</code> 外面 `</strong> weak<code>, 在内部再</code>__strong`.<br>这里有个例子需要理解</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-98d02c315523d276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="例 1"><br><img src="http://upload-images.jianshu.io/upload_images/2131368-0c334ec2de2f09c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个例子中, 在 <code>block</code> 里面已经通过<code>__strong</code> 对对象引用计数加一,但为什么置为 <code>doctor</code> 置为 <code>nil</code>, 就被释放掉了那?<br>再看下面的例子:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-ed9d6587642ae69e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="例 2"><br><img src="http://upload-images.jianshu.io/upload_images/2131368-3bb88da42b5adcf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个例子为什么只有 <code>doctor</code>是空那?<br>结合两个例子, 引用计数的改变是一个动态改变, 只有被强引用之后, 引用计数才会加一。</p>
<p>#####分析例 1：<br>在 <code>doctor</code> 置为 <code>nil</code> 之前, <code>block</code> 的<code>__ strong</code> 并没有执行, 所以当时 <code>doctor</code> 对象被当前的区块持有, 当 <code>doctor</code> 置为 <code>nil</code> 时, 该对象已经被释放, 所以 <code>__strong</code> 的时候, <code>weak</code> 地址的内存已经被释放, strong 指向 nil,  所以 doctor 对象引用计数并没有加 1.</p>
<p>#####分析例 2：<br>在 <code>doctor</code> 被置为<code>nil</code>之前执行<code>__ strong</code>, doctor 引用计数加 1,  对象被 <code>block</code> 持有,  执行 <code>doctor = nil</code> 之后, doctor 仍然被 <code>block</code> 持有.</p>
<p>说一下外面<code>__weak</code>,  里面<code>__strong</code>的好处, 在被<code>block</code>引用的时候,不会被 block 持有, 在<code>block</code>执行完毕, 立即将对象释放, 并不会造成循环引用, 而且还可以在多线程中, 在 <code>block</code> 区块内对对象持有.</p>
<p>这里有个概念就是区块持有和对象持有.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">     // 区块持有</div><div class="line">    // 在块内声明的变量, 在块执行完毕立即被释放.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对象持有: 地址指向内存.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先说一下循环引用, 为什么没用&lt;code&gt;__weak&lt;/code&gt; 修饰就直接用 &lt;code&gt;self.&lt;/code&gt;属性不会造成循环引用.&lt;br&gt;循环引用是指两个或者多个对象循环持有造成的无法释放.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>类别（Category）添加weak （property）属性，关联（Associated）</title>
    <link href="https://yansaid.github.io/2016/03/21/%E7%B1%BB%E5%88%AB/"/>
    <id>https://yansaid.github.io/2016/03/21/类别/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2017-04-05T01:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Category 在平常代码中经常使用，在使用第三方工具时，遇到工具不能直接解决当前问题的情况，我就会使用到Category，通过给特定的类加一个方法来处理这种情况。<br>本文仅仅介绍给（Category）加 weak 属性。<br><a id="more"></a><br>weak：修饰OBJC对象，不会持有指向修饰对象，同样指向的对象引用计数就不会增加，当指向的对象被释放释放的时候，weak修饰的对象会被置为nil。<br>因为堆内存是动态的，所以当某个地址的对象被释放的时候，所有指向他的指针都应该被置为空。weak就是为了满足避免循环引用，同时在对象被释放的时候可以被置为空的情况而存在的。<br>assign是为了修饰栈内存中的数值对象，当使用assign修饰了一个OBJC对象的时候，可能造成野指针。原因在上面刚刚提到。</p>
<p>进入主题：给 Category 添加 weak 属性。<br>首先，给 Category 属性是需要使用runtime中的关联来实现set 和 get 方法。但runtime只提供如下几种修饰实现，并没有weak。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class="line">OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.</div><div class="line">*   The association is not made atomically. */</div><div class="line">OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.</div><div class="line">*   The association is not made atomically. */</div><div class="line">OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</div><div class="line">*   The association is made atomically. */</div><div class="line">OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</div><div class="line">*   The association is made atomically. */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>看了别人的思路之后，加以修改。runtime没有开放weak解决方案，所以只能模仿 weak 的思路来实现. 思路是这样的，让需要被 weak 修饰的对象去持有一个 strong 的对象，然后当被修饰的对象被释放的时候，持有的对象也会被释放，那么我们就可以捕捉到释放的事件，进而使用OBJC_ASSOCIATION_ASSIGN 来实现弱引用，在释放事件里面再将其释放掉，进而实现weak功能。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-499f0c8db94c56fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 定义一个对象，使用block来回调析构函数。</div><div class="line">typedef void (^DeallocBlock)();</div><div class="line">@interface OriginalObject : NSObject</div><div class="line">@property (nonatomic, copy) DeallocBlock block;</div><div class="line">- (instancetype)initWithBlock:(DeallocBlock)block;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation OriginalObject</div><div class="line"></div><div class="line">- (instancetype)initWithBlock:(DeallocBlock)block</div><div class="line">&#123;</div><div class="line">self = [super init];</div><div class="line">if (self) &#123;</div><div class="line">self.block = block;</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line">- (void)dealloc &#123;</div><div class="line">self.block ? self.block() : nil;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Category添加属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// Category</div><div class="line">// NSObject+property.h</div><div class="line">@interface NSObject (property)</div><div class="line">@property (nonatomic, weak) id objc_weak_id;</div><div class="line">@end</div><div class="line"></div><div class="line">// NSObject+property.m</div><div class="line">@implementation NSObject (property)</div><div class="line">- (id)objc_weak_id &#123;</div><div class="line">return objc_getAssociatedObject(self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setObjc_weak_id:(id)objc_weak_id &#123;</div><div class="line">OriginalObject *ob = [[OriginalObject alloc] initWithBlock:^&#123;</div><div class="line">objc_setAssociatedObject(self, @selector(objc_weak_id), nil, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">&#125;];</div><div class="line">// 这里关联的key必须唯一，如果使用_cmd，对一个对象多次关联的时候，前面的对象关联会失效。</div><div class="line">// 给需要被 assign 修饰的对象添加一个 strong 对象.</div><div class="line">objc_setAssociatedObject(objc_weak_id, (__bridge const void *)(ob.block), ob, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">objc_setAssociatedObject(self, @selector(objc_weak_id), objc_weak_id, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tips: 一个不被持有的对象是不能被 weak 指向. 即,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">A *a = [[A alloc] init];</div><div class="line">self.weakObj = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样写是不成立的, a 会在{}执行之后便释放掉, self.weakObj 指向 nil. 所以上面 objc_weak_id 要关联一个 retain 的对象.</p>
<p>具体体验weak 和 assgin的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,weak) id      weakPoint;</div><div class="line">@property (nonatomic,assign) id    assignPoint;</div><div class="line">@property (nonatomic,strong) id    strongPoint;</div><div class="line"></div><div class="line">self.strongPoint = [NSDate date];</div><div class="line">self.weakPoint = self.strongPoint;</div><div class="line">self.assignPoint = self.strongPoint;</div><div class="line">self.strongPoint = nil;</div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 0x0 指针置为空。</div><div class="line">NSLog(@&quot;%p&quot;, self.assignPoint); // crash 因为self.assignPoint指针指向的对象已经被释放。</div></pre></td></tr></table></figure></p>
<p>测试weak是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self.strongPoint = [NSDate date];</div><div class="line">self.objc_weak_id = self.strongPoint;</div><div class="line">self.weakPoint = self.strongPoint;</div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 指针。</div><div class="line">NSLog(@&quot;%p&quot;, self.objc_weak_id); // print 相同的指针。</div><div class="line">self.strongPoint = nil;</div><div class="line"></div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 0x0 指针置为空。</div><div class="line">NSLog(@&quot;%p&quot;, self.objc_weak_id); // print 0x0 指针置为空。</div></pre></td></tr></table></figure></p>
<p>在Category中添加 property 相对添加方法少一些，而添加weak property是少之又少，但实现 通过这次实践，你可以明白什么是weak，什么是assign，而不是仅仅知道delegate中用weak，NSInteger用assign。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Category 在平常代码中经常使用，在使用第三方工具时，遇到工具不能直接解决当前问题的情况，我就会使用到Category，通过给特定的类加一个方法来处理这种情况。&lt;br&gt;本文仅仅介绍给（Category）加 weak 属性。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
</feed>
