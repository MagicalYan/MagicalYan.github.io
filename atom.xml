<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yan Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yansaid.github.io/"/>
  <updated>2017-04-05T08:29:19.000Z</updated>
  <id>https://yansaid.github.io/</id>
  
  <author>
    <name>Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome To Yan&#39;s Website.</title>
    <link href="https://yansaid.github.io/2222/02/22/Me/"/>
    <id>https://yansaid.github.io/2222/02/22/Me/</id>
    <published>2222-02-21T16:00:00.000Z</published>
    <updated>2017-04-05T08:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt -->
<audio id="audioList" autoplay="autoplay"><br>// 那就这样吧<br><source src="http://onk403mwf.bkt.clouddn.com/%E9%99%AA%E6%88%91%E7%9C%8B%E6%97%A5%E5%87%BA.m4a" type="audio/mpeg"><br><br><source src="http://onk403mwf.bkt.clouddn.com/%E9%82%A3%E5%B9%B4%E6%98%A5%E5%A4%A9%E4%B8%8B%E7%9D%80%E9%9B%AA.m4a" type="audio/mpeg"><br><br><source src="http://onk403mwf.bkt.clouddn.com/%E9%9C%80%E8%A6%81%E4%BA%BA%E9%99%AA.m4a" type="audio/mpeg"><br><br><source src="http://onk403mwf.bkt.clouddn.com/%E9%82%A3%E5%B0%B1%E8%BF%99%E6%A0%B7%E5%90%A7.m4a" type="audio/mpeg"><br><br><source src="http://onk403mwf.bkt.clouddn.com/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC.mp4" type="audio/mpeg"><br><br><source src="http://onk403mwf.bkt.clouddn.com/%E7%88%B1%E6%83%85%E5%BA%9F%E6%9F%B4.m4a" type="audio/mpeg"><br><br></audio>

<script>
let urls = [
'http://onk403mwf.bkt.clouddn.com/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%F0%9F%8E%82.mp3',
'http://onk403mwf.bkt.clouddn.com/%E9%99%AA%E6%88%91%E7%9C%8B%E6%97%A5%E5%87%BA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%82%A3%E5%B9%B4%E6%98%A5%E5%A4%A9%E4%B8%8B%E7%9D%80%E9%9B%AA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%9C%80%E8%A6%81%E4%BA%BA%E9%99%AA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%82%A3%E5%B0%B1%E8%BF%99%E6%A0%B7%E5%90%A7.m4a',
'http://onk403mwf.bkt.clouddn.com/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC.mp4',
'http://onk403mwf.bkt.clouddn.com/%E7%88%B1%E6%83%85%E5%BA%9F%E6%9F%B4.m4a'
];
var index = 0;
myAudio=document.getElementById("audioList");
myAudio.onended = function()
{
    if (index == urls.length - 1) index = -1;
    myAudio.src = urls[++index];
    myAudio.loop=false;
    myAudio.load();
};
</script>

<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 进来听听歌。&lt;/p&gt;
    
    </summary>
    
      <category term="introduce" scheme="https://yansaid.github.io/categories/introduce/"/>
    
    
      <category term="essay" scheme="https://yansaid.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>__attribute__((cleanup(function))</title>
    <link href="https://yansaid.github.io/2016/10/28/attribute%E4%BD%BF%E7%94%A8/"/>
    <id>https://yansaid.github.io/2016/10/28/attribute使用/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2017-04-05T01:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>__attribute__</code> 是一个编译命令, 可以为变量、函数、类型定义提供一些属性.<br><code>__attribute__</code>有很多属性deprecated、unused、cleanup等等， 本文主要讲 cleanup.<br><a id="more"></a><br>cleanup 变量作用域结束之前, 走 cleanup 方法.</p>
<p>基本功能:<br>变量作用域结束之前, 执行cleanup指定的方法,方法的参数为变量的地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-9139f7951f968b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-698d86c538b7a3cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面是, 当 block 作用域结束的时候让 cleanup 执行的具体实现.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static void cleanBlock(__strong void(^*block)(void))  &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if DEBUG</div><div class="line">#define keywordify autoreleasepool &#123;&#125;</div><div class="line">#else</div><div class="line">#define keywordify try &#123;&#125; @catch (...) &#123;&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">#define onExit \</div><div class="line">keywordify \</div><div class="line">__strong void(^block)(void) __attribute__((cleanup(cleanBlock), unused)) = ^</div></pre></td></tr></table></figure></p>
<p><code>keywordify</code> 的作用就是在使用的时候可以在前面加一个@, 可以防止 return-type warning, 使用<code>autoreleasepool</code>的时候会创建一个没有实际意义的自动释放池.<br>所以使用<code>@try/@catch/@finally</code>来实现前面加@.</p>
<p>具体可参考 ReactiveCocoa2.5 版本 “RACmetamacros.h”.</p>
<p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        NSLock *lock = [[NSLock alloc] init];</div><div class="line">        [lock lock];</div><div class="line">        @onExit &#123;</div><div class="line">            [lock unlock];</div><div class="line">            NSLog(@&quot;end&quot;);</div><div class="line">        &#125;;</div><div class="line">        sleep(5);</div><div class="line">        NSLog(@&quot;begin&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log:begin</div><div class="line">log:end</div></pre></td></tr></table></figure>
<p>onExit 主要的作用是在某个块执行结束, 自动执行 block, 避免了忘记 unlock.</p>
<p>如果想让代码在{}最后执行都可以使用 onExit.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 是一个编译命令, 可以为变量、函数、类型定义提供一些属性.&lt;br&gt;&lt;code&gt;__attribute__&lt;/code&gt;有很多属性deprecated、unused、cleanup等等， 本文主要讲 cleanup.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>objective-c 的消息转发</title>
    <link href="https://yansaid.github.io/2016/07/15/objective-c%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>https://yansaid.github.io/2016/07/15/objective-c消息转发/</id>
    <published>2016-07-14T16:00:00.000Z</published>
    <updated>2017-04-05T01:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>objc 在执行一个方法的时候是如何判断一个方法是否存在的?</p>
<a id="more"></a>
<ol>
<li>从本类和父类中查找.</li>
<li>检查是否动态添加方法.</li>
<li>查看是否存在快速消息转发.</li>
<li>查看标准消息转发.</li>
</ol>
<p>1-4是按照顺序进行的, 若在某个环节查到符合的方法, 下面的查找则终止.</p>
<ol>
<li>我就不具体解释了.</li>
<li><p>objc 是一门动态的语言, 它允许在运行时, 向一个类添加属性、方法等. class_addMethod、class_addIvar、class_addProperty、class_addProtocol. 具体使用就不介绍了. 需要重写 resolveInstanceMethod 方法, 在其中判断需要添加的方法, 使用class_addMethod来动态添加方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+(BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    if(aSEL == @selector(methodName))&#123;</div><div class="line">        class_addMethod(Class cls, SEL name, IMP imp,</div><div class="line">        const char *types) ;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NSObject 提供快速消息转发方法, 只要重新</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>之后, 每次在父类本类中找不到, 并且没有找到动态添加方法, 则会走该方法, 你可以在这个方法中, return 目标对象, 则目标对象执行 aSelector. 如果没有重写标准消息转发, 并且 return nil, 则会报 <code>unrecognized selector sent to instance</code> 这个错误.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    Person *person = [[Person alloc]init];</div><div class="line">        if ([person respondsToSelector:aSelector]) &#123;</div><div class="line">        return person;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.标准消息转发, 主要可以实现多对象同时转发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 生成一个方法, 并存入表中</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    if (!signature) &#123;</div><div class="line">        signature = [yourObj methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    return signature; // 将一个新签名的方法放入表中</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现动态添加方法, 并执行方法</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    SEL seletor = [anInvocation selector];</div><div class="line">    if ([yourObj respondsToSelector:seletor]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:yourObj];</div><div class="line">    &#125;</div><div class="line">    // 这里可以转发若干个你想转发的对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方法的 invoke 大概应该是这样实现的</div><div class="line">// 相当于 class_addMethod, 将 yourObj 中的方法  IMP 给了[self class].</div><div class="line">- (void) invokeWithTarget:(id)target &#123;</div><div class="line">    Method method = class_getInstanceMethod([target class], aSelector);</div><div class="line">    class_addMethod([self class],</div><div class="line">    aSelector,</div><div class="line">    method_getImplementation(method),</div><div class="line">    method_getTypeEncoding(method));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;objc 在执行一个方法的时候是如何判断一个方法是否存在的?&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>一个react native 的第三方, 附 npm 发布教程.</title>
    <link href="https://yansaid.github.io/2016/06/30/tipsView/"/>
    <id>https://yansaid.github.io/2016/06/30/tipsView/</id>
    <published>2016-06-29T16:00:00.000Z</published>
    <updated>2017-04-05T01:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个我日常开发所使用的工具, 会在日后不断在 GitHub 上更新.<br>目前提供手写板的功能和截图的功能.<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/2131368-62683a0f099fd8d8.gif?imageMogr2/auto-orient/strip" alt=""><br>使用: npm i –save react-native-tipsview</p>
<p>具体使用请看demo: <a href="https://github.com/yansaid/RNTipsView/tree/master/Example" target="_blank" rel="external">https://github.com/yansaid/RNTipsView/tree/master/Example</a><br>运行 demo: 下载代码, 进入 Example/tips,<br>nmp install<br>进入 ios 工程直接运行项目即可, 目前仅支持 iOS.</p>
<p>npm 发布流程:</p>
<ol>
<li><p>首先注册npm 账号:<br><a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a>,免费的即可.</p>
</li>
<li><p>生成 package.json :<br>npm 上面的信息都包含在 package.json 文件中.<br>首先在控制台进入想要发布的 package 目录,<br>然后在控制台输入 npm init , 此时正在配置 package.json 文件.<br>配置信息包括很多.<br>name : 唯一标示, 必须全部为小写, npm i –save<code>react-native-tipsview</code>中, <code>react-native-tipsview</code>就是name.<br>version : 版本号.<br>description : 描述信息, 你查看发布后的包的描述就可以看见.<br>main : 入口文件.<br>keywords : 关键词, 主要用于搜索时.</p>
</li>
</ol>
<p>还有很多配置信息可自行搜索学习, 例如 GitHub 等等, 其中 name, 和 version 是必要字段, 没有则无法发布.</p>
<ol>
<li>发布<br><code>npm publish --registry http://registry.npmjs.org</code></li>
</ol>
<p>等待发布完毕, 可以尝试使用一下.</p>
<p>GitHub: <a href="https://github.com/yansaid/RNTipsView" target="_blank" rel="external">https://github.com/yansaid/RNTipsView</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个我日常开发所使用的工具, 会在日后不断在 GitHub 上更新.&lt;br&gt;目前提供手写板的功能和截图的功能.&lt;br&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://yansaid.github.io/categories/React-Native/"/>
    
    
      <category term="react native" scheme="https://yansaid.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>__strong、__weak、__block.</title>
    <link href="https://yansaid.github.io/2016/05/03/block/"/>
    <id>https://yansaid.github.io/2016/05/03/block/</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2017-04-05T01:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下循环引用, 为什么没用<code>__weak</code> 修饰就直接用 <code>self.</code>属性不会造成循环引用.<br>循环引用是指两个或者多个对象循环持有造成的无法释放.<br><a id="more"></a><br>类 <code>Person</code> 有个属性 <code>block</code>, 在 <code>block</code> 实现后, 此时 <code>self</code> 持有 <code>block</code>, 如果在 <code>block</code> 中, 直接使用 <code>self</code>, <code>block</code> 将持有 <code>self</code>, 造成循环引用, 如果 <code>block</code> 本身不是 <code>self</code> 的属性, 则 <code>self</code>不持有 <code>block</code>, 即使在 <code>block</code> 中直接使用 <code>self</code> 也不会造成循环引用, 但是为了避免多个对象的循环引用, 所以 <code>block</code> 中最好还是用<code>__weak</code>, 防止这种情况出现. 代理用 <code>weak</code> 与此同理.</p>
<p>__block:<br>使外部变量可以在 <code>Block</code> 内部进行修改.<br><img src="http://upload-images.jianshu.io/upload_images/2131368-4b64251e2b00e4a3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-d2d3f4e1e2394432?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>输出:<br>num:2, pointer:0xb000000000000022<br>blockNum:3, pointer:0xb000000000000032<br>可见 <strong> block 会拷贝原来对象,  </strong>block修饰的对象可被 Block 内外同时修改.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-2547ebf5885ccbef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可见 <code>doctor</code> 和 <code>self</code> 被 <code>block</code> 持有, 即使没有使用<code>__ block</code> 修饰,但他们的属性依然可以被修改, 不会像上面的 <code>num = @3;</code> 那样报错禁止修改, 和 <code>NSArray</code> 是一样的, <code>NSArray</code> 本身是不可修改的, 但是 NSArray 里面存放的对象依然是可以修改的.</p>
<p>__weak:<br><img src="http://upload-images.jianshu.io/upload_images/2131368-ed78fc9023d519ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2131368-b1c3b8f30a523dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>weak</code>的实现,  将当前对象(= 右边的对象)值的地址存入 <code>weak hash</code> 表, <code>hash</code> 表中的 <code>key</code> 是 <code>weak</code> 对象的地址, <code>value</code> 是当前对象(= 右边的对象)值的地址, 当每次访问<code>weak</code> 对象的时候, 首先找到 <code>key</code>, 再找到 <code>value</code>. 当当前对象的值被释放, <code>weak hash</code> 表将 <code>value</code> 设置为<code>nil</code>.  如果理解不了, 可以看一下 C语言的指针, 指针的指针.</p>
<p>__weak 的作用: <code>weak</code> 表中的指向的对象, 不计入引用计数. 不持有对象, 但可以引用对象, 不参与对象释放.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-188aa742ee71c5f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2131368-252e85de5c25330e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可见被<code>__weak</code> 修饰过的对象, 不会被 <code>block</code> 持有,所以在对象释放的时候, <code>block</code> 中的 <code>weak</code> 对象也被置为 <code>nil</code>.</p>
<p>但有一种特殊的情况,  就是存放在栈区的对象并不会因为引用对象的释放而释放.<br><img src="http://upload-images.jianshu.io/upload_images/2131368-5cb84159fe6dd19a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-b23a175a0bfa213a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>字符串常量是存在栈区的, 栈内存并不会动态释放, 而是当当前线程执行完毕后, 释放当前线程的栈内存. 所有的常量都存在栈区.<br>所以上面的例子中即使使用<code>__ weak</code> 修饰, 但是<code>@&quot;aa&quot;</code>这个常量并没有被释放, 所以 <code>weak</code>的地址指向依然存在值.</p>
<p><strong>strong:<br>在某个块内对当前对象引用计数加一.<br>在 AFN 中经常出现 <code>block</code> 外面 `</strong> weak<code>, 在内部再</code>__strong`.<br>这里有个例子需要理解</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-98d02c315523d276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2131368-0c334ec2de2f09c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个例子中, 在 <code>block</code> 里面已经通过<code>__strong</code> 对对象引用计数加一,但为什么置为 <code>doctor</code> 置为 <code>nil</code>, 就被释放掉了那?<br>再看下面的例子:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-ed9d6587642ae69e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2131368-3bb88da42b5adcf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个例子为什么只有 <code>doctor</code>是空那?<br>结合两个例子, 引用计数的改变是一个动态改变, 只有被强引用之后, 引用计数才会加一, 我们看第一个例子, 在 <code>doctor</code> 置为 <code>nil</code> 之前, <code>block</code> 的<code>__ strong</code> 并没有执行, 所以当时 <code>doctor</code> 对象当前的区块持有, 当 <code>doctor</code> 置为 <code>nil</code> 的时候, 该对象已经被释放, 所以 <code>__strong</code> 的时候, <code>weak</code> 地址的内存已经被释放, 所以并没有对 doctor 对象引用加一.</p>
<p>下面的例子刚好是在 <code>doctor</code> 被置为<code>nil</code>之前执行<code>__ strong</code>, 对象被 <code>block</code> 块持有, 没有被释放.</p>
<p>说一下外面<code>__weak</code>,  里面<code>__strong</code>的好处, 在被<code>block</code>引用的时候,不会被 block 持有, 在<code>block</code>执行完毕, 立即将对象释放, 并不会造成循环引用, 而且还可以在多线程中, 在 <code>block</code> 区块内对对象持有.</p>
<p>这里有个概念就是区块持有和对象持有.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">// 区块持有</div><div class="line">// 在块内声明的变量, 在块执行完毕立即被释放.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对象持有: 地址指向内存.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先说一下循环引用, 为什么没用&lt;code&gt;__weak&lt;/code&gt; 修饰就直接用 &lt;code&gt;self.&lt;/code&gt;属性不会造成循环引用.&lt;br&gt;循环引用是指两个或者多个对象循环持有造成的无法释放.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>类别（Category）添加weak （property）属性，关联（Associated）</title>
    <link href="https://yansaid.github.io/2016/03/21/%E7%B1%BB%E5%88%AB/"/>
    <id>https://yansaid.github.io/2016/03/21/类别/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2017-04-05T01:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Category 在平常代码中经常使用，在使用第三方工具时，遇到工具不能直接解决当前问题的情况，我就会使用到Category，通过给特定的类加一个方法来处理这种情况。<br>本文仅仅介绍给（Category）加 weak 属性。<br><a id="more"></a><br>weak：修饰OBJC对象，不会持有指向修饰对象，同样指向的对象引用计数就不会增加，当指向的对象被释放释放的时候，weak修饰的对象会被置为nil。<br>因为堆内存是动态的，所以当某个地址的对象被释放的时候，所有指向他的指针都应该被置为空。weak就是为了满足避免循环引用，同时在对象被释放的时候可以被置为空的情况而存在的。<br>assign是为了修饰栈内存中的数值对象，当使用assign修饰了一个OBJC对象的时候，可能造成野指针。原因在上面刚刚提到。</p>
<p>进入主题：给 Category 添加 weak 属性。<br>首先，给 Category 属性是需要使用runtime中的关联来实现set 和 get 方法。但runtime只提供如下几种修饰实现，并没有weak。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class="line">OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.</div><div class="line">*   The association is not made atomically. */</div><div class="line">OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.</div><div class="line">*   The association is not made atomically. */</div><div class="line">OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</div><div class="line">*   The association is made atomically. */</div><div class="line">OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</div><div class="line">*   The association is made atomically. */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>看了别人的思路之后，加以修改。runtime没有开放weak解决方案，所以只能模仿 weak 的思路来实现. 思路是这样的，让需要被 weak 修饰的对象去持有一个 strong 的对象，然后当被修饰的对象被释放的时候，持有的对象也会被释放，那么我们就可以捕捉到释放的事件，进而使用OBJC_ASSOCIATION_ASSIGN 来实现弱引用，在释放事件里面再将其释放掉，进而实现weak功能。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-499f0c8db94c56fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 定义一个对象，使用block来回调析构函数。</div><div class="line">typedef void (^DeallocBlock)();</div><div class="line">@interface OriginalObject : NSObject</div><div class="line">@property (nonatomic, copy) DeallocBlock block;</div><div class="line">- (instancetype)initWithBlock:(DeallocBlock)block;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation OriginalObject</div><div class="line"></div><div class="line">- (instancetype)initWithBlock:(DeallocBlock)block</div><div class="line">&#123;</div><div class="line">self = [super init];</div><div class="line">if (self) &#123;</div><div class="line">self.block = block;</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line">- (void)dealloc &#123;</div><div class="line">self.block ? self.block() : nil;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Category添加属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// Category</div><div class="line">// NSObject+property.h</div><div class="line">@interface NSObject (property)</div><div class="line">@property (nonatomic, weak) id objc_weak_id;</div><div class="line">@end</div><div class="line"></div><div class="line">// NSObject+property.m</div><div class="line">@implementation NSObject (property)</div><div class="line">- (id)objc_weak_id &#123;</div><div class="line">return objc_getAssociatedObject(self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setObjc_weak_id:(id)objc_weak_id &#123;</div><div class="line">OriginalObject *ob = [[OriginalObject alloc] initWithBlock:^&#123;</div><div class="line">objc_setAssociatedObject(self, @selector(objc_weak_id), nil, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">&#125;];</div><div class="line">// 这里关联的key必须唯一，如果使用_cmd，对一个对象多次关联的时候，前面的对象关联会失效。</div><div class="line">// 给需要被 assign 修饰的对象添加一个 strong 对象.</div><div class="line">objc_setAssociatedObject(objc_weak_id, (__bridge const void *)(ob.block), ob, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">objc_setAssociatedObject(self, @selector(objc_weak_id), objc_weak_id, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tips: 一个不被持有的对象是不能被 weak 指向. 即,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">A *a = [[A alloc] init];</div><div class="line">self.weakObj = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样写是不成立的, a 会在{}执行之后便释放掉, self.weakObj 指向 nil. 所以上面 objc_weak_id 要关联一个 retain 的对象.</p>
<p>具体体验weak 和 assgin的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,weak) id      weakPoint;</div><div class="line">@property (nonatomic,assign) id    assignPoint;</div><div class="line">@property (nonatomic,strong) id    strongPoint;</div><div class="line"></div><div class="line">self.strongPoint = [NSDate date];</div><div class="line">self.weakPoint = self.strongPoint;</div><div class="line">self.assignPoint = self.strongPoint;</div><div class="line">self.strongPoint = nil;</div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 0x0 指针置为空。</div><div class="line">NSLog(@&quot;%p&quot;, self.assignPoint); // crash 因为self.assignPoint指针指向的对象已经被释放。</div></pre></td></tr></table></figure></p>
<p>测试weak是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self.strongPoint = [NSDate date];</div><div class="line">self.objc_weak_id = self.strongPoint;</div><div class="line">self.weakPoint = self.strongPoint;</div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 指针。</div><div class="line">NSLog(@&quot;%p&quot;, self.objc_weak_id); // print 相同的指针。</div><div class="line">self.strongPoint = nil;</div><div class="line"></div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 0x0 指针置为空。</div><div class="line">NSLog(@&quot;%p&quot;, self.objc_weak_id); // print 0x0 指针置为空。</div></pre></td></tr></table></figure></p>
<p>在Category中添加 property 相对添加方法少一些，而添加weak property是少之又少，但实现 通过这次实践，你可以明白什么是weak，什么是assign，而不是仅仅知道delegate中用weak，NSInteger用assign。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Category 在平常代码中经常使用，在使用第三方工具时，遇到工具不能直接解决当前问题的情况，我就会使用到Category，通过给特定的类加一个方法来处理这种情况。&lt;br&gt;本文仅仅介绍给（Category）加 weak 属性。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
</feed>
