<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yan Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yansaid.github.io/"/>
  <updated>2017-03-31T02:34:31.000Z</updated>
  <id>https://yansaid.github.io/</id>
  
  <author>
    <name>Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>objective-c 的消息转发</title>
    <link href="https://yansaid.github.io/2017/03/29/objective-c%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>https://yansaid.github.io/2017/03/29/objective-c消息转发/</id>
    <published>2017-03-29T04:28:59.000Z</published>
    <updated>2017-03-31T02:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>objc 在执行一个方法的时候是如何判断一个方法是否存在的?</p>
<ol>
<li>从本类和父类中查找.</li>
<li>检查是否动态添加方法.</li>
<li>查看是否存在快速消息转发.</li>
<li>查看标准消息转发.</li>
</ol>
<p>1-4是按照顺序进行的, 若在某个环节查到符合的方法, 下面的查找则终止.</p>
<ol>
<li>我就不具体解释了.</li>
<li><p>objc 是一门动态的语言, 它允许在运行时, 向一个类添加属性、方法等. class_addMethod、class_addIvar、class_addProperty、class_addProtocol. 具体使用就不介绍了. 需要重写 resolveInstanceMethod 方法, 在其中判断需要添加的方法, 使用class_addMethod来动态添加方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+(BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    if(aSEL == @selector(methodName))&#123;</div><div class="line">        class_addMethod(Class cls, SEL name, IMP imp, </div><div class="line">        const char *types) ;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NSObject 提供快速消息转发方法, 只要重新</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>之后, 每次在父类本类中找不到, 并且没有找到动态添加方法, 则会走该方法, 你可以在这个方法中, return 目标对象, 则目标对象执行 aSelector. 如果没有重写标准消息转发, 并且 return nil, 则会报 <code>unrecognized selector sent to instance</code> 这个错误.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    Person *person = [[Person alloc]init];</div><div class="line">        if ([person respondsToSelector:aSelector]) &#123;</div><div class="line">        return person;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.标准消息转发, 主要可以实现多对象同时转发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 生成一个方法, 并存入表中</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    if (!signature) &#123;</div><div class="line">        signature = [yourObj methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    return signature; // 将一个新签名的方法放入表中</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现动态添加方法, 并执行方法</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    SEL seletor = [anInvocation selector];</div><div class="line">    if ([yourObj respondsToSelector:seletor]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:yourObj];</div><div class="line">    &#125;</div><div class="line">    // 这里可以转发若干个你想转发的对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方法的 invoke 大概应该是这样实现的</div><div class="line">// 相当于 class_addMethod, 将 yourObj 中的方法  IMP 给了[self class].</div><div class="line">- (void) invokeWithTarget:(id)target &#123;</div><div class="line">    Method method = class_getInstanceMethod([target class], aSelector);</div><div class="line">    class_addMethod([self class],</div><div class="line">    aSelector,</div><div class="line">    method_getImplementation(method),</div><div class="line">    method_getTypeEncoding(method));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;objc 在执行一个方法的时候是如何判断一个方法是否存在的?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从本类和父类中查找.&lt;/li&gt;
&lt;li&gt;检查是否动态添加方法.&lt;/li&gt;
&lt;li&gt;查看是否存在快速消息转发.&lt;/li&gt;
&lt;li&gt;查看标准消息转发.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1-4是按
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>__attribute__((cleanup(function))</title>
    <link href="https://yansaid.github.io/2017/03/29/attribute%E4%BD%BF%E7%94%A8/"/>
    <id>https://yansaid.github.io/2017/03/29/attribute使用/</id>
    <published>2017-03-29T03:16:40.000Z</published>
    <updated>2017-03-31T02:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>__attribute__</code> 是一个编译命令, 可以为变量、函数、类型定义提供一些属性.<br><code>__attribute__</code>有很多属性deprecated、unused、cleanup等等， 本文主要讲 cleanup.</p>
<p>cleanup 变量作用域结束之前, 走 cleanup 方法.<br>基本功能:<br>变量作用域结束之前, 执行cleanup指定的方法,方法的参数为变量的地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-9139f7951f968b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-698d86c538b7a3cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面是, 当 block 作用域结束的时候让 cleanup 执行的具体实现.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static void cleanBlock(__strong void(^*block)(void))  &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if DEBUG</div><div class="line">#define keywordify autoreleasepool &#123;&#125;</div><div class="line">#else</div><div class="line">#define keywordify try &#123;&#125; @catch (...) &#123;&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">#define onExit \</div><div class="line">keywordify \</div><div class="line">__strong void(^block)(void) __attribute__((cleanup(cleanBlock), unused)) = ^</div></pre></td></tr></table></figure></p>
<p><code>keywordify</code> 的作用就是在使用的时候可以在前面加一个@, 可以防止 return-type warning, 使用<code>autoreleasepool</code>的时候会创建一个没有实际意义的自动释放池.<br>所以使用<code>@try/@catch/@finally</code>来实现前面加@.</p>
<p>具体可参考 ReactiveCocoa2.5 版本 “RACmetamacros.h”.</p>
<p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        NSLock *lock = [[NSLock alloc] init];</div><div class="line">        [lock lock];</div><div class="line">        @onExit &#123;</div><div class="line">            [lock unlock];</div><div class="line">            NSLog(@&quot;end&quot;);</div><div class="line">        &#125;;</div><div class="line">        sleep(5);</div><div class="line">        NSLog(@&quot;begin&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log:begin</div><div class="line">log:end</div></pre></td></tr></table></figure>
<p>onExit 主要的作用是在某个块执行结束, 自动执行 block, 避免了忘记 unlock.</p>
<p>如果想让代码在{}最后执行都可以使用 onExit.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 是一个编译命令, 可以为变量、函数、类型定义提供一些属性.&lt;br&gt;&lt;code&gt;__attribute__&lt;/code&gt;有很多属性deprecated、unused、cleanup等等， 本文主要讲 cleanup.&lt;/p
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
</feed>
