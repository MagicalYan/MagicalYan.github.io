<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yan Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yansaid.github.io/"/>
  <updated>2017-10-26T03:48:38.331Z</updated>
  <id>https://yansaid.github.io/</id>
  
  <author>
    <name>Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome To Yan&#39;s Website!</title>
    <link href="https://yansaid.github.io/2222/02/22/Me/"/>
    <id>https://yansaid.github.io/2222/02/22/Me/</id>
    <published>2222-02-21T16:00:00.000Z</published>
    <updated>2017-10-26T03:48:38.331Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p>
<script>
let urls = [
'http://onk403mwf.bkt.clouddn.com/%E9%99%AA%E6%88%91%E7%9C%8B%E6%97%A5%E5%87%BA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%82%A3%E5%B9%B4%E6%98%A5%E5%A4%A9%E4%B8%8B%E7%9D%80%E9%9B%AA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%9C%80%E8%A6%81%E4%BA%BA%E9%99%AA.m4a',
'http://onk403mwf.bkt.clouddn.com/%E9%82%A3%E5%B0%B1%E8%BF%99%E6%A0%B7%E5%90%A7.m4a',
'http://onk403mwf.bkt.clouddn.com/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8C%97%E4%BA%AC.mp4',
'http://onk403mwf.bkt.clouddn.com/%E7%88%B1%E6%83%85%E5%BA%9F%E6%9F%B4.m4a'
];
var index = parseInt(Math.random() * (urls.length - 1), 10);
var myAudio = document.createElement("audio");
loadAudioAtIndex(index);
function loadAudioAtIndex(index) {
  myAudio.src = urls[index];
  myAudio.loop = false;
  myAudio.play();
}
myAudio.onended = function()
{
  if (index == urls.length - 1) index = -1;
  loadAudioAtIndex(++index);
};
</script>

<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Songs&lt;br&gt;
    
    </summary>
    
      <category term="introduce" scheme="https://yansaid.github.io/categories/introduce/"/>
    
    
      <category term="essay" scheme="https://yansaid.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>自定义翻转动画, 获取不到 from view</title>
    <link href="https://yansaid.github.io/2017/08/08/transition/"/>
    <id>https://yansaid.github.io/2017/08/08/transition/</id>
    <published>2017-08-07T16:00:00.000Z</published>
    <updated>2017-08-08T10:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近根据产品需求, 更改翻转动画, 很多时候我们只是改一下 to view 的 frame 来满足需求, 但当要 from view 动起来就出现很多坑了.</p>
<a id="more"></a>
<p>首先说一下通过 <code>viewControllerForKey</code>然后<code>.view</code>来获取 to view 和 from view 与使用<code>viewForKey</code>来获取的区别, 如果 to 和 from view 都与 animator 关联, 那么就没有区别了, 但苹果在这里设置了一个坑, 解释如下:</p>
<p>(本文说的 from view 是 present 时候的 from view, dismiss 时候的 to view)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Currently only two keys are defined by the system -</div><div class="line">// UITransitionContextFromViewKey, and UITransitionContextToViewKey</div><div class="line">// viewForKey: may return nil which would indicate that the animator should not</div><div class="line">// manipulate the associated view controller&apos;s view.</div><div class="line">- (nullable __kindof UIView *)viewForKey:(UITransitionContextViewKey)key NS_AVAILABLE_IOS(8_0);</div></pre></td></tr></table></figure>
<p>ok, 如果使用 <code>viewForKey</code> 获取不到 view, 那么我们使用 <code>viewControllerForKey</code> 获取 view 不就肯定没问题了吗?<br>答案是错误的, 因为 如果 to 和 from view 没和 animator 关联, 那么这个 view 就不可以加交互动画, 当你 dismiss 的时候动画立刻执行完成, 根本不受 <code>updateInteractiveTransition</code> 的控制, 说到这里我们必须说一下什么情况会发生未关联这种情况, 看苹果解释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// If NO is returned from -shouldRemovePresentersView, the view associated</div><div class="line">// with UITransitionContextFromViewKey is nil during presentation.  This</div><div class="line">// intended to be a hint that your animator should NOT be manipulating the</div><div class="line">// presenting view controller&apos;s view.  For a dismissal, the -presentedView</div><div class="line">// is returned.</div><div class="line">//</div><div class="line">// Why not allow the animator manipulate the presenting view controller&apos;s</div><div class="line">// view at all times?  First of all, if the presenting view controller&apos;s</div><div class="line">// view is going to stay visible after the animation finishes during the</div><div class="line">// whole presentation life cycle there is no need to animate it at all — it</div><div class="line">// just stays where it is.  Second, if the ownership for that view</div><div class="line">// controller is transferred to the presentation controller, the</div><div class="line">// presentation controller will most likely not know how to layout that</div><div class="line">// view controller&apos;s view when needed, for example when the orientation</div><div class="line">// changes, but the original owner of the presenting view controller does.</div><div class="line">    UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</div><div class="line"></div><div class="line">// Indicate whether the view controller&apos;s view we are transitioning from will be removed from the window in the end of the</div><div class="line">// presentation transition</div><div class="line">// (Default: NO)</div><div class="line">@property(nonatomic, readonly) BOOL shouldRemovePresentersView;</div></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/library/content/samplecode/CustomTransitions/Listings/CustomTransitions_Custom_Presentation_AAPLCustomPresentationController_m.html" target="_blank" rel="external">解释具体位置</a></p>
<p><code>shouldRemovePresentersView</code>这个属性在哪里那?<br>苹果提供 管理 交互动画的 控制器 <code>UIPresentationController</code>,<br>只要继承这个类, 并重写你需要的方法, 就可以在交互过程中, 完成你想要的效果, 重写下面方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)presentationTransitionWillBegin;</div><div class="line">- (void)presentationTransitionDidEnd:(BOOL)completed;</div><div class="line">- (void)dismissalTransitionWillBegin;</div><div class="line">- (void)dismissalTransitionDidEnd:(BOOL)completed;</div></pre></td></tr></table></figure>
<p>说了这么多, 回到主题, 如何让 from view 和 animator 关联,<br>只要继承 <code>UIPresentationController</code>类, 自定义一个<code>SomePresentationController</code>重写 <code>shouldRemovePresentersView</code> get方法, 返回 YES, 就关联了, default 是 NO, 如果不重写, 你永远获取不到 from view.</p>
<p>同时, 需要实现 <code>UIViewControllerTransitioningDelegate</code> 的相应代理方法, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(UIViewController *)presenting sourceViewController:(UIViewController *)source &#123;</div><div class="line">    SomePresentationController *presentation = [[SomePresentationController alloc]initWithPresentedViewController:presented presentingViewController:presenting];</div><div class="line">    return presentation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)shouldRemovePresentersView &#123;</div><div class="line">    return YES; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后说几句, 如果不看苹果的那个 demo , 你可能永远不知道自己错哪了, 当我看到下面的那几句解释, 整个人都释然了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// If NO is returned from -shouldRemovePresentersView, the view associated</div><div class="line">// with UITransitionContextFromViewKey is nil during presentation.  This</div><div class="line">// intended to be a hint that your animator should NOT be manipulating the</div><div class="line">// presenting view controller&apos;s view.  For a dismissal, the -presentedView</div><div class="line">// is returned.</div></pre></td></tr></table></figure></p>
<p><a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html#//apple_ref/doc/uid/TP40007457-CH16-SW1" target="_blank" rel="external">苹果事例链接</a></p>
<p><a href="https://developer.apple.com/library/content/samplecode/CustomTransitions/Listings/CustomTransitions_Custom_Presentation_AAPLCustomPresentationController_m.html" target="_blank" rel="external">苹果的 demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近根据产品需求, 更改翻转动画, 很多时候我们只是改一下 to view 的 frame 来满足需求, 但当要 from view 动起来就出现很多坑了.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>UIBezierPath 如何通过 point.x 获取到 point.y</title>
    <link href="https://yansaid.github.io/2017/07/17/UIbezierPath/"/>
    <id>https://yansaid.github.io/2017/07/17/UIbezierPath/</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-07-17T09:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>UIBezierPath 有固定的数学公式, ok, 不多说, 直接拿出公式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C(t) = (1 - t)^2 * P(0) + 2 * t * (1 - t) * P(1) + t^2 * P(2)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>P(0) 代表起始点<br>P(1) 代表 control point<br>P(2) 代表终点</p>
<p>只要给出三个点, 同时 <code>t</code> 值, 从 0 - 1 改变, 就得到了一条曲线, 也就是我们常用的方法 <code>addQuadCurveToPoint:controlPoint:</code> , 既然知道公式, 我们也知道 P(0)、P(1)、P(2)，只要通过 x 求出 <code>t</code>, 在通过 <code>t</code> 来回推出 y 即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">根据上面的公式可得出: </div><div class="line">X = (1 - t)^2 * X0 + 2 * t * (1 - t) * X1 + t^2 * X2 </div><div class="line">经过换算:</div><div class="line">t = (X - X0) / (2 * (X1 - X0))</div><div class="line">再把 `t` 代入下面的方程式中, 即可获得 y</div><div class="line">Y = (1 - t)^2 * Y0 + 2 * t *(1 - t) * Y1 + t^2 * Y2</div></pre></td></tr></table></figure>
<p>下面是具体实现, 可以直接使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/* see https://stackoverflow.com/questions/26857850/get-points-from-a-uibezierpath/26858983</div><div class="line"> Given the equation</div><div class="line"> </div><div class="line"> X = (1-t)^2*X0 + 2*t*(1-t)*X1 + t^2 *X2</div><div class="line"> I solve for t</div><div class="line"> </div><div class="line"> t = ((2.0 * x0 - x1) + sqrt(((-2.0 * x0 + x1) ** 2.0)</div><div class="line"> - ((4 * (x0 - 2.0 * x1 + x2)) * (x0 - x)))) / (2.0 * (x0 - 2.0 * x1 + x2))</div><div class="line"> or</div><div class="line"> </div><div class="line"> t = ((2.0 * x0 - x1) - sqrt(((-2.0 * x0 + x1) ** 2.0)</div><div class="line"> - ((4 * (x0 - 2.0 * x1 + x2)) * (x0 - x)))) / (2.0 * (x0 - 2.0 * x1 + x2))</div><div class="line"> Using this value, find Y that corresponds to X (we used X to find the above t value)</div><div class="line"> </div><div class="line"> Y = (1-t)^2*Y0 + 2*t*(1-t)*Y1 + t^2 *Y2</div><div class="line"> */</div><div class="line">- (float)getYFromBezierPath:(float)x start:(CGPoint)start ctrlpt:(CGPoint)ctrlpt end:(CGPoint)end &#123;</div><div class="line">    float y;</div><div class="line">    float t;</div><div class="line">    t = [self getTvalFromBezierPath:x x0:start.x x1:ctrlpt.x x2:end.x];</div><div class="line">    y = [self getCoordFromBezierPath:t y0:start.y y1:ctrlpt.y y2:end.y];</div><div class="line">    return y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// x0 start point x, x1 control point x, x2 end point x</div><div class="line">- (float)getTvalFromBezierPath:(float)x x0:(float)x0 x1:(float)x1 x2:(float)x2 &#123;</div><div class="line">    float t = (x - x0) / (2 * (x1 - x0));</div><div class="line">    return t;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//y0 start point y, y1 control point y, y2 end point y</div><div class="line">- (float)getCoordFromBezierPath:(float)t y0: (float)y0 y1: (float)y1 y2: (float)y2 &#123;</div><div class="line">    return (pow((1 - t), 2) * y0) + (2 * t * (1 - t) * y1) + (pow(t, 2) * y2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###by the way<br>比较简单的获取 <code>control point</code> 的方法, <code>control point</code> 主要是控制曲线的弯曲程度, 这个方法获取的 <code>control point</code> 可以满足日常绘制曲线, 但特俗的需求, 需要自定义修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)controlPointWithP1:(CGPoint)p1 p2:(CGPoint)p2 &#123;</div><div class="line">    CGPoint point = [self centerWithP1:p1 p2:p2];</div><div class="line">    CGFloat differY = fabs(p1.y - point.y);</div><div class="line">    if (p1.y &gt; p2.y) &#123;</div><div class="line">        point.y -= differY;</div><div class="line">    &#125; else &#123;</div><div class="line">        point.y += differY;</div><div class="line">    &#125;</div><div class="line">    return point;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGPoint)centerWithP1:(CGPoint)p1 p2:(CGPoint)p2 &#123;</div><div class="line">    return CGPointMake((p1.x + p2.x) / 2.0f, (p1.y + p2.y) / 2.0f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考: <a href="https://stackoverflow.com/questions/26857850/get-points-from-a-uibezierpath" target="_blank" rel="external">Get points from a UIBezierPath</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UIBezierPath 有固定的数学公式, ok, 不多说, 直接拿出公式:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;C(t) = (1 - t)^2 * P(0) + 2 * t * (1 - t) * P(1) + t^2 * P(2)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>关于 FMDB 线程问题</title>
    <link href="https://yansaid.github.io/2017/06/08/fmdb/"/>
    <id>https://yansaid.github.io/2017/06/08/fmdb/</id>
    <published>2017-06-07T16:00:00.000Z</published>
    <updated>2018-02-26T07:01:56.357Z</updated>
    
    <content type="html"><![CDATA[<p>目前比较火的 iOS 端的数据库, realm、CoreData、FMDB, 就学习成本看来，FMDB 应该是最低的，本文主要说 FMDB 多线程造成  locked 的问题, 和主线程阻塞问题。<br><a id="more"></a><br>当 查询、插入、 删除、 更新 同时对同一数据操作的时候， 就会造成 “database is locked” , 而且会存在数据安全问题, 如何避免这种情况发生? 最简单的方法就是在同一个线程中对数据库进行操作,  什么是同一个线程? 我们日常开发中经常使用到 <code>dispatch_async</code> 和 <code>dispatch_sync</code>,  <code>dispatch_async</code> 一定会开辟一个新线程吗?<br>答案是不一定, 当 <code>dispatch_async</code> 使用在一个串行队列中, 这个串行队列中只有一个线程, 而且所有的  <code>dispatch_async</code>  是顺序执行的, 所以只有最开始用的时候, 会开辟一个线程。 <code>dispatch_sync</code> 可以阻塞当前线程和后面的队列(目标队列)，因为  <code>dispatch_sync</code> 是在当前队列的当前线程执行一段代码, 所以如果使用  <code>dispatch_sync</code> 进行一段耗时操作, 肯定会阻塞当前线程。当  <code>dispatch_async</code>  使用并行队列的时候，每次都会开辟一个新线程 (前提是前面的线程都没执行完, 如果执行完也会复用)， <code>dispatch_sync</code> 和串行的效果是相同的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-4663a7179ccb19d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><a href="https://github.com/yansaid/HYDatabaseManager" target="_blank" rel="external">HYDatabaseManager</a> 我之前自己也基于 FMDB 封装了一个,, 如果感兴趣的可以看一下。</p>
<p>这篇文章主要针对于使用了 FMDB , 但不知道为什么会 locked 和 sleep 的同学。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前比较火的 iOS 端的数据库, realm、CoreData、FMDB, 就学习成本看来，FMDB 应该是最低的，本文主要说 FMDB 多线程造成  locked 的问题, 和主线程阻塞问题。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>关于 OC 的循环引用, 特俗情况</title>
    <link href="https://yansaid.github.io/2017/06/05/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
    <id>https://yansaid.github.io/2017/06/05/循环引用/</id>
    <published>2017-06-04T16:00:00.000Z</published>
    <updated>2017-06-05T06:36:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>一说起循环引用, 首先肯定想到的是 <code>block</code> 和 <code>代理</code>，解决方法就是使用 <code>weak</code> 来弱引用.<br><a id="more"></a></p>
<p>#####什么是循环引用?<br>有两个对象 A 和 B, A 强引用 B, 并且 B 强引用 A, 这就是循环引用, 因为两个对象互相强引用, 所以两个对象都不会被释放.</p>
<p>block 的循环引用请看: <a href="http://www.jianshu.com/p/34400360ce7e" target="_blank" rel="external">block 循环引用, <code>__strong、__weak、__block</code>使用规则</a></p>
<p>#####无法直接通过 <code>weak</code> 来解决循环引用的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(selector)];</div><div class="line">[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [self.displayLink invalidate];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码, 我希望在 dealloc 的时候将 <code>CADisplayLink</code> 对象释放掉, 但是 <code>CADisplayLink</code> 在 <code>displayLinkWithTarget</code> 方法中,  <code>CADisplayLink</code> 对象会强引用 <code>self</code>, 如此看来, <code>self</code> 和 self.displayLink 已经出现循环引用,  那么如何在不主动执行 <code>[self.displayLink invalidate];</code> 的前提下将 <code>self</code> 释放掉?</p>
<p>首先我们都会想到使用 <code>__weak</code> 来实现, 但是, 在 <code>CADisplayLink</code> 内部被强引用, 怎么实现这个 <code>weak</code>?</p>
<p>既然两个对象无法解决, 我们就加一个对象, 或者更多, 只要, 这个闭环中有一个对象是 <code>weak</code> 的, 那么循环引用就不成立了, 那么怎么加这个对象那, 在之前的文章(<a href="http://www.jianshu.com/p/3bb4595ba686" target="_blank" rel="external">objective-c 的消息转发</a>)中, 提到过消息转发.</p>
<p>我们现在新加一个类叫做 <code>WeakTarget</code>, 让它的事例去持有 weak 的 <code>self</code>, 让  <code>self.displayLink</code> 持有 <code>WeakTarget</code> 的事例, ok, <code>self</code> 本身是持有 <code>self.displayLink</code> 的, 这样就不是一个闭环了, 如下图.<br><img src="http://upload-images.jianshu.io/upload_images/2131368-26e20a389fe86c74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>现在, 只要实现 <code>WeakTarget</code> 将消息转发给 self 就可以了,<br>实现很简单, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// class WeakTarget</div><div class="line">@property (nonatomic, weak) id target;</div><div class="line">- (instancetype)initWithTarget:(id)target &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        self.target = target;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (id)forwardingTargetForSelector:(SEL)selector &#123;</div><div class="line">    return self.target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:[[WeakTarget alloc] initWithTarget:self] selector:@selector(selector)];</div><div class="line">[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [self.displayLink invalidate];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>消息转发的具体细节请看<a href="http://www.jianshu.com/p/3bb4595ba686" target="_blank" rel="external">objective-c 的消息转发</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一说起循环引用, 首先肯定想到的是 &lt;code&gt;block&lt;/code&gt; 和 &lt;code&gt;代理&lt;/code&gt;，解决方法就是使用 &lt;code&gt;weak&lt;/code&gt; 来弱引用.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>全局静态变量 和 全局变量 的区别</title>
    <link href="https://yansaid.github.io/2017/05/25/%E5%85%A8%E5%B1%80%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <id>https://yansaid.github.io/2017/05/25/全局静态变量/</id>
    <published>2017-05-24T16:00:00.000Z</published>
    <updated>2017-05-25T10:01:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于近几年一直在敲 oc, 在 oc 中使用的 c 并不多, 于是把这些给忘了。<br>最近看 react-native 的源码的时候，最先入手的是<code>RCT_EXPORT_MODULE()</code>, 这个宏到底是干嘛的那 ?<br><a id="more"></a><br>ok, 我们来看源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define RCT_EXPORT_MODULE(js_name) \</div><div class="line">RCT_EXTERN void RCTRegisterModule(Class); \</div><div class="line">+ (NSString *)moduleName &#123; return @#js_name; &#125; \</div><div class="line">+ (void)load &#123; RCTRegisterModule(self); &#125;</div></pre></td></tr></table></figure>
<p><code>moduleName</code> 是添加一个类方法, 可以返回定义的 js_name, 没什么好说的, 往下看 <code>+ (void)load { RCTRegisterModule(self);</code> 重写 <code>load</code> 的方法, 在 <code>load</code> 中执行了 <code>RCTRegisterModule</code>, 我们看一下, 这个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static NSMutableArray&lt;Class&gt; *RCTModuleClasses;</div><div class="line">void RCTRegisterModule(Class);</div><div class="line">void RCTRegisterModule(Class moduleClass)</div><div class="line">&#123;</div><div class="line">  static dispatch_once_t onceToken;</div><div class="line">  dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    RCTModuleClasses = [NSMutableArray new];</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  RCTAssert([moduleClass conformsToProtocol:@protocol(RCTBridgeModule)],</div><div class="line">            @&quot;%@ does not conform to the RCTBridgeModule protocol&quot;,</div><div class="line">            moduleClass);</div><div class="line">  // Register module</div><div class="line">  [RCTModuleClasses addObject:moduleClass];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ok，我们终于讲到正题, 我定义一个 <code>Test</code> 类, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//.m</div><div class="line">#import &quot;Test.h&quot;</div><div class="line">void RCTRegisterModule(Class moduleClass)</div><div class="line">&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        RCTModuleClasses = [NSMutableArray new];</div><div class="line">    &#125;);</div><div class="line">    // Register module</div><div class="line">    [RCTModuleClasses addObject:moduleClass];</div><div class="line">&#125;</div><div class="line">@implementation Test</div><div class="line">@end</div><div class="line"></div><div class="line">//.h</div><div class="line">void RCTRegisterModule(Class);</div><div class="line">static NSMutableArray&lt;Class&gt; *RCTModuleClasses;</div><div class="line"></div><div class="line">@interface Test : NSObject</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当我在 <code>APPDelegate</code> 中, 调用和打印:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RCTRegisterModule(self.class);</div><div class="line">NSLog(@&quot;%@&quot;, RCTModuleClasses);</div><div class="line"></div><div class="line">log: (null)</div></pre></td></tr></table></figure></p>
<p>这里为什么会是空的那? 我明明调用了<code>RCTRegisterModule</code>, 而且<code>RCTModuleClasses</code> 还是一个单利, ok, 接下来我使用全局变量来试一下,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//.m</div><div class="line">#import &quot;Test.h&quot;</div><div class="line">NSMutableArray&lt;Class&gt; *RCTModuleClasses;</div><div class="line">void RCTRegisterModule(Class moduleClass)</div><div class="line">&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        RCTModuleClasses = [NSMutableArray new];</div><div class="line">    &#125;);</div><div class="line">    // Register module</div><div class="line">    [RCTModuleClasses addObject:moduleClass];</div><div class="line">&#125;</div><div class="line">@implementation Test</div><div class="line">@end</div><div class="line"></div><div class="line">//.h</div><div class="line">void RCTRegisterModule(Class);</div><div class="line">extern NSMutableArray&lt;Class&gt; *RCTModuleClasses;</div><div class="line"></div><div class="line">@interface Test : NSObject</div><div class="line"></div><div class="line">- (void)hahah;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当我在 <code>APPDelegate</code> 中, 调用和打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RCTRegisterModule(self.class);</div><div class="line">NSLog(@&quot;%@&quot;, RCTModuleClasses);</div><div class="line"></div><div class="line">log: (</div><div class="line">    AppDelegate</div><div class="line">)</div></pre></td></tr></table></figure>
<p>带着疑惑 Google 了一下, 全局静态变量 和 全局变量的区别, 全局静态变量是有作用域的, 只可以被声明的.h .m / .c 中访问到, 全局变量是没有作用域的，无论在任何地方，引入一下 Test.h，便可以获得并使用全局变量。</p>
<p>当然还有一个局部静态变量, 就是在块 <code>{}</code> 中可以访问, 他与普通局部变量的区别就是, 局部静态变量 的作用是保持变量内容的持久。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于近几年一直在敲 oc, 在 oc 中使用的 c 并不多, 于是把这些给忘了。&lt;br&gt;最近看 react-native 的源码的时候，最先入手的是&lt;code&gt;RCT_EXPORT_MODULE()&lt;/code&gt;, 这个宏到底是干嘛的那 ?&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
      <category term="C" scheme="https://yansaid.github.io/categories/iOS/C/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 实现排序算法</title>
    <link href="https://yansaid.github.io/2017/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://yansaid.github.io/2017/05/11/排序算法/</id>
    <published>2017-05-10T16:00:00.000Z</published>
    <updated>2017-05-25T10:08:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>当数据量很大的时候, 可以清晰的看出 快速排序的优势。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">// 冒泡排序 优化</div><div class="line">// 正常是 for 循环 从后一直冒泡, 优化是, 如果当某次循环, 所有位置没有发生改动, 那么证明排序已经完成, 直接 break。</div><div class="line"></div><div class="line">- (NSArray *)bubbleBetter:(NSMutableArray *)a &#123;</div><div class="line">    if (a.count &lt;= 1) return [a copy];</div><div class="line">    BOOL flag = true;</div><div class="line">    for (int i = 0; i &lt; a.count - 1; i++) &#123;</div><div class="line">        if (!flag) &#123;</div><div class="line">            return [a copy];</div><div class="line">        &#125;</div><div class="line">        flag = false;</div><div class="line">        for (NSInteger j = 1; j &lt; a.count - i; j++) &#123;</div><div class="line">            if ([a[j - 1] integerValue] &gt; [a[j] integerValue]) &#123;</div><div class="line">                [a exchangeObjectAtIndex:j - 1 withObjectAtIndex:j];</div><div class="line">                flag = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return [a copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 选择排序 优化</div><div class="line">// 每次循环，找出最大的和最小的，放两边，继续查找剩余的部分。</div><div class="line">- (NSArray *)selector:(NSMutableArray *)a &#123;</div><div class="line">    if (a.count &lt;= 1) return [a copy];</div><div class="line">    NSInteger count = a.count;</div><div class="line">    for (int i = 0; i &lt; a.count / 2; i++) &#123;</div><div class="line">        NSInteger min = i;</div><div class="line">        NSInteger max = i;</div><div class="line">        for (int j = i + 1; j &lt; count - i; j++) &#123;</div><div class="line">            if ([a[j] integerValue] &lt; [a[min] integerValue]) &#123;</div><div class="line">                min = j;</div><div class="line">            &#125; else if ([a[j] integerValue] &gt; [a[max] integerValue]) &#123;</div><div class="line">                max = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        [a exchangeObjectAtIndex:i withObjectAtIndex:min];</div><div class="line">        [a exchangeObjectAtIndex:count - i - 1 withObjectAtIndex:max];</div><div class="line">    &#125;</div><div class="line">    return [a copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 快速排序 </div><div class="line">// 是从某个数开始，左边是全部小于这个数的集合， 右边是全部大于这个数的集合，通过不断递归将所有数据排完。</div><div class="line">- (NSArray *)quick:(NSMutableArray *)a min:(NSInteger)min max:(NSInteger)max &#123;</div><div class="line">    if (a.count &lt;= 1) return [a copy];</div><div class="line">    if (max - min &lt;= 0) return [a copy];</div><div class="line">    NSInteger centerIndex = (max - min) / 2 + min;</div><div class="line">    NSInteger center = [a[centerIndex] integerValue];</div><div class="line">    NSInteger moveTimes = 0;</div><div class="line">    for (NSInteger i = min; i &lt; max; i++) &#123;</div><div class="line">        if (i == centerIndex) &#123;</div><div class="line">            i += moveTimes;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (i &lt; centerIndex) &#123;</div><div class="line">            if ([a[i] integerValue] &gt; center) &#123;</div><div class="line">                id temp = a[i];</div><div class="line">                [a insertObject:temp atIndex:centerIndex + 1];</div><div class="line">                [a removeObjectAtIndex:i];</div><div class="line">                centerIndex--;</div><div class="line">                i--;</div><div class="line">                moveTimes++;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if ([a[i] integerValue] &lt; center) &#123;</div><div class="line">                id temp = a[i];</div><div class="line">                [a insertObject:temp atIndex:centerIndex];</div><div class="line">                [a removeObjectAtIndex:i + 1];</div><div class="line">                centerIndex++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    [self quick:a min:min max:centerIndex];</div><div class="line">    [self quick:a min:centerIndex + 1 max:max];</div><div class="line">    return [a copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当数据量很大的时候, 可以清晰的看出 快速排序的优势。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 解耦</title>
    <link href="https://yansaid.github.io/2017/05/09/uitableview%20%E8%A7%A3%E8%80%A6/"/>
    <id>https://yansaid.github.io/2017/05/09/uitableview 解耦/</id>
    <published>2017-05-08T16:00:00.000Z</published>
    <updated>2017-05-09T04:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>产品开发的时候无法避免的就是在一个 <code>UITableView</code>中, 包含多种样式的 <code>cell</code>, 我们通常的做法如下:<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (indexPath.row == 0) &#123;</div><div class="line">      </div><div class="line">&#125; else if (indexPath.row == 1) &#123;</div><div class="line"></div><div class="line">&#125; else if (indexPath.row == 2) &#123;</div><div class="line"></div><div class="line">&#125; .....</div></pre></td></tr></table></figure>
<p>这样的做法没有问题, 但是如果有很多种 <code>cell</code> 的话, 例如资料页, 当需要在第二和第三个 <code>cell</code> 之间插入一个 <code>cell</code> 的时候, 我们需要把数组添加一列, 然后把整个 <code>if</code> 改一遍, 如何避免 <code>index</code> 之间的耦合? </p>
<p>OK, 简单来说就是在<code>数据模型</code> 中添加一个标识, 数据的排列交给数组, 我们不判断当前是第几个, 只根据标识来确定放那种样式的<code>cell</code>,<br>这样只有当增加新的样式的时候才会涉及到改 UI 部分的代码, 大部分情况我们只需要对数组进行排序即可, 而不必因为该数组, 从而再改 <code>if</code>.</p>
<p>###下面来介绍一款专门为了解耦而写的第三方: <a href="https://github.com/yansaid/HYTableViewSection" target="_blank" rel="external">HYTableViewSection</a></p>
<p>使用方法:<br><code>pod &#39;HYTableViewSection&#39;</code></p>
<p>通过构建数据来实现布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">HYTableViewRow *row = [HYTableViewRow row:@&#123;@&quot;title&quot;:@&quot;style1&quot;&#125;];</div><div class="line">row.identifier = @&quot;style1&quot;;</div><div class="line">row.heightBlock = ^CGFloat&#123;</div><div class="line">    return 100;  // heightBlock 可以使用计算复杂高度, 或者直接使用 row.height</div><div class="line">&#125;;</div><div class="line">[self.tableView.hy_section addRowModel:row atSection:0];</div><div class="line"></div><div class="line">HYTableViewRow *row1 = [HYTableViewRow row:@&#123;@&quot;title&quot;:@&quot;style2&quot;&#125;];</div><div class="line">row1.identifier = @&quot;style2&quot;;</div><div class="line">row1.heightBlock = ^CGFloat&#123;</div><div class="line">    return 150;</div><div class="line">&#125;;</div><div class="line">[self.tableView.hy_section addRowModel:row1 atSection:0];</div><div class="line"></div><div class="line"></div><div class="line">HYTableViewRow *row2 = [HYTableViewRow row:@&#123;@&quot;title&quot;:@&quot;style3&quot;&#125;];</div><div class="line">row2.identifier = @&quot;style3&quot;;</div><div class="line">row2.heightBlock = ^CGFloat&#123;</div><div class="line">    return 80;</div><div class="line">&#125;;</div><div class="line">[self.tableView.hy_section addRowModel:row2 atSection:1];</div></pre></td></tr></table></figure>
<p>代理方法中使用技巧, 除了新增 <code>style</code> 几乎不会涉及改 <code>UITableView</code> 的代理方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    HYTableViewRow *row = [self.tableView.hy_section modelAtIndexPath:indexPath];</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:row.identifier];</div><div class="line">    if (!cell) &#123;</div><div class="line">        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:row.identifier];</div><div class="line">    &#125;</div><div class="line">    cell.textLabel.text = row.model[@&quot;title&quot;];</div><div class="line">    if ([row.identifier isEqualToString:@&quot;style1&quot;]) &#123;</div><div class="line">        cell.contentView.backgroundColor = [UIColor redColor];</div><div class="line">    &#125; else if ([row.identifier isEqualToString:@&quot;style2&quot;]) &#123;</div><div class="line">        cell.contentView.backgroundColor = [UIColor greenColor];</div><div class="line">    &#125; else if ([row.identifier isEqualToString:@&quot;style3&quot;]) &#123;</div><div class="line">        cell.contentView.backgroundColor = [UIColor blueColor];</div><div class="line">    &#125;</div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    HYTableViewRow *row = [self.tableView.hy_section modelAtIndexPath:indexPath];</div><div class="line">    return row.height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">    return [self.tableView.hy_section numberOfRowsInSection:section];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class="line">    return [self.tableView.hy_section numberOfSections];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;产品开发的时候无法避免的就是在一个 &lt;code&gt;UITableView&lt;/code&gt;中, 包含多种样式的 &lt;code&gt;cell&lt;/code&gt;, 我们通常的做法如下:&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Tagged Pointer, weak string 不释放.</title>
    <link href="https://yansaid.github.io/2017/04/25/Tagged%20Pointer/"/>
    <id>https://yansaid.github.io/2017/04/25/Tagged Pointer/</id>
    <published>2017-04-24T16:00:00.000Z</published>
    <updated>2017-04-25T07:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近被 NSString 无法释放这件事搞得糊涂。<br>首先说一下，发现问题的过程：<br><a id="more"></a></p>
<p>有两个 weak properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, weak) id a;</div><div class="line">@property (nonatomic, weak) id sa;</div></pre></td></tr></table></figure></p>
<p>按道理来说, 当一个对象初始化就赋给了一个 weak 对象, 这个对象就会立刻被释放掉, 但有一个特俗的情况, 看下面的代码和输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        NSString *temp = @&quot;sa&quot;;</div><div class="line">        NSMutableString *sa = [[NSMutableString alloc] initWithString:temp];</div><div class="line">        NSMutableArray *array = [NSMutableArray arrayWithObject:@&quot;aaa&quot;];</div><div class="line">        self.a = [array copy];</div><div class="line">        self.sa = [sa copy];</div><div class="line">        NSLog(@&quot;array:%p&quot;, array);</div><div class="line">        NSLog(@&quot;self.a:%p&quot;, self.a);</div><div class="line">        NSLog(@&quot;self.sa:%p&quot;, self.sa);</div><div class="line">        NSLog(@&quot;temp:%p&quot;, temp);</div><div class="line">&#125;</div><div class="line">array:0x600000241ad0</div><div class="line">self.a:0x0</div><div class="line">self.sa:0xa000000000061732</div><div class="line">temp:0x1081d0030</div></pre></td></tr></table></figure>
<p>为什么 self.sa 没有被释放?<br>到这里我们来引入 <a href="https://mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="external"><code>Tagged Pointer</code></a> 这个概念.</p>
<p>对于那些所需内存小于60位的字符串，它可以创建一个Tagged Pointer。其余的则被放置在真正的NSString对象里。这使得常用的短字符串的性能得到明显的提升。<br>NSNumber、NSDate等, 都是使用  <a href="https://mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="external"><code>Tagged Pointer</code></a>.</p>
<p>当你重复运行的时候, 发现 self.sa 的地址, 始终没有发生变化, 其实那并不是对象的地址, 而是直接指向数据的指针.</p>
<p>可以发现实际的地址 <code>self.sa:0xa000000000061732</code> 对应的数据格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0x2 - Length (2)</div><div class="line">0x73 - &apos;s&apos; </div><div class="line">0x61 - &apos;a&apos;</div></pre></td></tr></table></figure></p>
<p>当我改代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        NSString *temp = @&quot;saaaaaaaaaaa&quot;;</div><div class="line">        NSMutableString *sa = [[NSMutableString alloc] initWithString:temp];</div><div class="line">        NSMutableArray *array = [NSMutableArray arrayWithObject:@&quot;aaa&quot;];</div><div class="line">        self.a = [array copy];</div><div class="line">        self.sa = [sa copy];</div><div class="line">        NSLog(@&quot;array:%p&quot;, array);</div><div class="line">        NSLog(@&quot;self.a:%p&quot;, self.a);</div><div class="line">        NSLog(@&quot;self.sa:%p&quot;, self.sa);</div><div class="line">        NSLog(@&quot;temp:%p&quot;, temp);</div><div class="line">        </div><div class="line">&#125;</div><div class="line">array:0x600000055300</div><div class="line">self.a:0x0</div><div class="line">self.sa:0x0</div><div class="line">temp:0x109c74030</div></pre></td></tr></table></figure></p>
<p>发现 self.sa 也变为 nil 了, 因为当长度大于60的时候,  <a href="https://mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="external"><code>Tagged Pointer</code></a>失效, 改用对象存储, 则初始化后立刻被释放掉了.</p>
<p>感谢 <a href="http://stackoverflow.com/users/431526/sven" target="_blank" rel="external">@sven</a> 在 <a href="http://stackoverflow.com/questions/43568704/when-a-weak-object-nsmutablestring-copy-who-holds-the-nsmutablestring-copy" target="_blank" rel="external">stackoverflow</a> 的解答.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被 NSString 无法释放这件事搞得糊涂。&lt;br&gt;首先说一下，发现问题的过程：&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Method Swizzling 的具体分析</title>
    <link href="https://yansaid.github.io/2017/04/10/swizziling/"/>
    <id>https://yansaid.github.io/2017/04/10/swizziling/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-06-02T02:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>OC 是一门动态的语言, runtime 的机制给开发者提供了许多新的可能, 在运行时, 可以动态为一个类添加方法和属性.<br><a id="more"></a></p>
<p>####首先说一下 objc_msgSend 执行方法<br> 现在我们有一个 Doctor 类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//  Doctor.m</div><div class="line">@implementation Doctor</div><div class="line"></div><div class="line">- (void)sayhello &#123;</div><div class="line">    NSLog(@&quot;hello&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们都知道不在.h 里面申明, .只在 .m 中实现的方法, 就相当于私有方法. 但并非绝对的私有.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Doctor *doctor = [[Doctor alloc] init];</div><div class="line">#pragma clang diagnostic push </div><div class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class="line">    [doctor performSelector:NSSelectorFromString(@&quot;sayhello&quot;) withObject:nil];</div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure>
<p>使用 perfromSelector 就可以直接掉用知道名字的方法.</p>
<p>perfromSelector相当于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Doctor *doctor = [[Doctor alloc] init];</div><div class="line">SEL sel = NSSelectorFromString(@&quot;sayhello&quot;);</div><div class="line">void (*sendMsg)(id, SEL) = (void (*)(id, SEL))objc_msgSend;</div><div class="line">sendMsg(doctor, sel);</div></pre></td></tr></table></figure></p>
<p>runtime 中使用 objc_msgSend 来执行所有的方法.  </p>
<p>####class_addMethod 动态添加方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SEL sel = NSSelectorFromString(@&quot;sayhello&quot;);</div><div class="line">// 获取当前类 method</div><div class="line">Method method = class_getInstanceMethod([self class], NSSelectorFromString(@&quot;sayhello&quot;));</div><div class="line">// 让 Doctor 指向当前类的 method</div><div class="line">class_addMethod([doctor class], sel, method_getImplementation(method), method_getTypeEncoding(method));</div><div class="line"></div><div class="line">//当前类声明一个方法</div><div class="line">- (void)sayhello &#123;</div><div class="line">    NSLog(@&quot;hello&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@implementation UIViewController (Tracking)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line">        </div><div class="line">        SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class="line">        </div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">        </div><div class="line">        // 将 originalMethod 指向 xxx_viewWillAppear: 的实现.</div><div class="line">        BOOL didAddMethod = </div><div class="line">        class_addMethod(class,</div><div class="line">                        originalSelector,</div><div class="line">                        method_getImplementation(swizzledMethod),</div><div class="line">                        method_getTypeEncoding(swizzledMethod));</div><div class="line">        </div><div class="line">        if (didAddMethod) &#123;</div><div class="line">    // 将 swizzledMethod 指向 viewWillAppear: 的实现.</div><div class="line">            class_replaceMethod(class,</div><div class="line">                                swizzledSelector,</div><div class="line">                                method_getImplementation(originalMethod),</div><div class="line">                                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method Swizzling</div><div class="line"></div><div class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self xxx_viewWillAppear:animated]; // 这里实际执行的是 viewWillAppear:</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调换两个方法的实现, 来实现, 捕捉原始方法的执行. 当需要捕捉某个方法执行, 一种方法是通过继承来实现, 另一种方法通过 Method Swizzling, 当有很多不同形态的子类存在的时候, 继承还是需要写很多重复代码.</p>
<p>首先说一下, 当通过 Method Swizzling 交换方法之后, 所有这个类的子类走这个交换过的方法都会, 在当前的实现中捕捉到, 所以, 在这个方法中的 self 是会发生变化的, 可能是任意一个 UIViewController 的子类.<br>即:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 所有 UIViewController 的子类和本身, 在走 viewWillAppear 之前都会走下面的方法</div><div class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self xxx_viewWillAppear:animated]; // 这里实际执行的是 viewWillAppear:</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>@sunny</code> 的 <code>xib的动态桥接</code> 中, 他捕捉了所有的 UIView 子类的 <code>awakeAfterUsingCoder</code> 方法, 并通过判断是否遵守协议来判断是否要进行处理, 所以只有在 UIView 子类种, 遵守 <code>XXNibBridge</code> 协议的子类才会被动态加载, 这是 Method Swizzling 一个很好的案例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 交换后的方法</div><div class="line">- (id)hackedAwakeAfterUsingCoder:(NSCoder *)decoder &#123;</div><div class="line">    if ([self.class conformsToProtocol:@protocol(XXNibBridge)] &amp;&amp; ((UIView *)self).subviews.count == 0) &#123;</div><div class="line">        // &quot;self&quot; is placeholder view for this moment, replace it.</div><div class="line">        return [XXNibBridgeImplementation instantiateRealViewFromPlaceholder:(UIView *)self];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://nshipster.cn/method-swizzling/" target="_blank" rel="external">Method Swizzling @Mattt Thompson</a></p>
<p><a href="http://blog.sunnyxx.com/2014/07/01/ios_ib_bridge/" target="_blank" rel="external">xib的动态桥接 @sunny</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC 是一门动态的语言, runtime 的机制给开发者提供了许多新的可能, 在运行时, 可以动态为一个类添加方法和属性.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>整洁的代码 - 适配器模式(Adaptor)</title>
    <link href="https://yansaid.github.io/2017/04/10/adaptor/"/>
    <id>https://yansaid.github.io/2017/04/10/adaptor/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-13T09:08:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是适配器模式?<br>例: 我们现在有很多不同种的螺母, 但只有一个螺钉, 螺钉都需要经过处理之后才可以用在螺母上, 处理螺钉的工具就叫做适配器。<br><a id="more"></a></p>
<p>日常开发中，经常遇到多个视图上需要呈现来自一处的数据, 每个视图的数据处理，就可以定义适配器, 对数据进行处理, 每个适配器对数据处理, 返回给对应的视图, 当然使用一个类来包含所有适配器是可以的, 但是如果过多的处理堆在一个类中, 不方便日后阅读, 所以我建议, 每个适配器都建一个类.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 声明 Adaptor</div><div class="line">@property (nonatomic, strong) id&lt;AdaptorProtocol&gt; adaptor;</div><div class="line"></div><div class="line">// 获取数据</div><div class="line">#pragma mark - APIManagerDelegate</div><div class="line">- (void)apiManagerDidSuccess:(APIManager *)manager &#123;</div><div class="line">    NSDictionary *datas = [manager fetchDataWithAdaptor:self.adaptor]; // 通知数据源, 提供数据给 Adaptor 并让 Adaptor 执行数据处理, 返回数据.</div><div class="line">    NSLog(@&quot;%@&quot;, datas);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 初始化</div><div class="line">- (id&lt;AdaptorProtocol&gt;)adaptor &#123;</div><div class="line">    if (!_adaptor) &#123;</div><div class="line">        _adaptor = [[Adaptor alloc] init];</div><div class="line">    &#125;</div><div class="line">    return _adaptor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 数据源 统一处理执行 Adaptor 的方法, 数据源不管你需要什么数据, 只把自己持有的数据给 Adaptor, 让 Adaptor 处理数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// APIManager.m</div><div class="line">- (NSDictionary *)fetchDataWithAdaptor:(id&lt;AdaptorProtocol&gt;)adaptor &#123;</div><div class="line">    if (adaptor == nil) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125; else &#123;</div><div class="line">        return [adaptor configDataWithManager:self]; // 执行数据处理</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//  Adaptor.h</div><div class="line">#import &quot;APIManager.h&quot;</div><div class="line"></div><div class="line">extern NSString * const kAdaptorKeyGender;</div><div class="line">extern NSString * const kAdaptorKeyName;</div><div class="line"></div><div class="line">@interface Adaptor : NSObject&lt;AdaptorProtocol&gt;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//  Adaptor.m</div><div class="line">#import &quot;Adaptor.h&quot;</div><div class="line"></div><div class="line">NSString * const kAdaptorKeyGender = @&quot;kAdaptorKeyGender&quot;;</div><div class="line">NSString * const kAdaptorKeyName = @&quot;kAdaptorKeyName&quot;;</div><div class="line"></div><div class="line">@implementation Adaptor</div><div class="line"></div><div class="line">- (NSDictionary *)configDataWithManager:(APIManager *)manager &#123;</div><div class="line">// 处理数据, 并返回数据</div><div class="line">    return @&#123;kAdaptorKeyName:manager.dic[@&quot;name&quot;], kAdaptorKeyGender:manager.dic[@&quot;gender&quot;]&#125;;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果需要一种新的数据格式, 就可以增加一个新的 Adaptor, 来做相应的处理即可.</p>
<p>使用适配模式, 主要是为了把数据处理从 view 中抽出来, 方便日后的测试和修改.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是适配器模式?&lt;br&gt;例: 我们现在有很多不同种的螺母, 但只有一个螺钉, 螺钉都需要经过处理之后才可以用在螺母上, 处理螺钉的工具就叫做适配器。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>NSString 为什么用 copy ? Block 为什么用 copy?</title>
    <link href="https://yansaid.github.io/2017/04/10/copy/"/>
    <id>https://yansaid.github.io/2017/04/10/copy/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-10T08:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>copy<br>深拷贝与浅拷贝的区别, 在于是否开辟新内存，copy 只针对堆内存对象而言。</p>
<p>浅拷贝：<br>拷贝的是地址，和对象的 = 赋值是一样的。<br>OC 中 我们声明一个 NSString 属性。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property NSString *str；</div></pre></td></tr></table></figure></p>
<p>为什么会有这个<em>, c 语言中, </em>是一个取值操作符, <em>str 对应的是值, 所以 str 是</em> str 的地址, 为什么要说这个那, 就是 = 传递的是对象的地址, 浅拷贝就是地址的拷贝.</p>
<p>提示：上面提到的只针对堆内存的对象。<br>&amp; 取址操作符，平常声明的值对象是存在栈内存中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int a = 5;</div></pre></td></tr></table></figure></p>
<p>a 对应的栈中存放的 5，&amp;a 对应栈内存地址。</p>
<p>#####深拷贝：<br>开辟新的内存空间，相当于声明了一个新的对象，对象中的值，与当前对象值相同。</p>
<p>NSString 为什么用 copy ?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSString *strongStr;</div><div class="line">@property (nonatomic, copy) NSString *cpyStr;</div></pre></td></tr></table></figure></p>
<p>我们有两个对象, 一个用 strong, 一个用 copy.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSString *tmpStr = @&quot;temp&quot;;</div><div class="line">self.strongStr = tmpStr;</div><div class="line">self.cpyStr = tmpStr;</div><div class="line"></div><div class="line">2017-04-10 12:06:11.953 Copy[66625:4617737] tmpStr:temp</div><div class="line">strongStr:temp</div><div class="line">cpyStr:temp</div><div class="line">2017-04-10 12:06:11.953 Copy[66625:4617737] tmpStr:0x10f096078</div><div class="line">strongStr:0x10f096078</div><div class="line">cpyStr:0x10f096078</div></pre></td></tr></table></figure></p>
<p>对于不可变字符串, copy 和 strong 都是浅拷贝.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSMutableString *tmpStr = [[NSMutableString alloc] initWithString:@&quot;temp&quot;];</div><div class="line">self.strongStr = tmpStr;</div><div class="line">self.cpyStr = tmpStr;</div><div class="line">[tmpStr appendString:@&quot; + add&quot;];</div><div class="line">NSLog(@&quot;tmpStr:%@\n strongStr:%@\n cpyStr:%@&quot;, tmpStr, self.strongStr, self.cpyStr);</div><div class="line">NSLog(@&quot;tmpStr:%p\n strongStr:%p\n cpyStr:%p&quot;, tmpStr, self.strongStr, self.cpyStr);</div><div class="line"></div><div class="line">2017-04-10 11:58:56.888 Copy[66562:4610424] </div><div class="line">tmpStr:temp + add</div><div class="line">strongStr:temp + add</div><div class="line">cpyStr:temp</div><div class="line">2017-04-10 11:58:56.888 Copy[66562:4610424] tmpStr:0x600000271580</div><div class="line">strongStr:0x600000271580</div><div class="line">cpyStr:0xa000000706d65744</div></pre></td></tr></table></figure>
<p>当 tmpStr 改变之后 strongStr 也改变了, 虽然 strongStr 是个不可变字符串, 但是它指向了一个可变字符串. 可以看见 cpyStr 是深拷贝, 它指向的内存和 tmpStr 完全不同.</p>
<p>NSMutableString 不可以使用 copy.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSMutableString *mutableString;</div></pre></td></tr></table></figure></p>
<p>copy 返回的都是不可变的, 所以当执行 <code>appendString:</code> 等NSMutableString特有的方法的时候, 会报<code>unrecognized selector sent to instance</code> 这个错误.</p>
<p>tips:<br>为什么 NSString 可以直接指向一个常量, 而 NSMutableString 不可以?<br>不可变字符串, 不可变, 他可以指向一个常量, 常量是不可变的, 存放在常量区.</p>
<p>Block 为什么用 copy?<br>代码块 是存在栈区的, 需要通过 copy 拷贝到堆内存, ARC 下, 赋值的时候编译器会自行对 block 进行 copy 操作, copy 到堆内存, 与一般的对象是相同的.<br>所以在 ARC 下 block 使用 copy 和 strong 是没有区别的.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;copy&lt;br&gt;深拷贝与浅拷贝的区别, 在于是否开辟新内存，copy 只针对堆内存对象而言。&lt;/p&gt;
&lt;p&gt;浅拷贝：&lt;br&gt;拷贝的是地址，和对象的 = 赋值是一样的。&lt;br&gt;OC 中 我们声明一个 NSString 属性。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>__attribute__((cleanup(function))</title>
    <link href="https://yansaid.github.io/2016/10/28/attribute%E4%BD%BF%E7%94%A8/"/>
    <id>https://yansaid.github.io/2016/10/28/attribute使用/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2017-04-05T01:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>__attribute__</code> 是一个编译命令, 可以为变量、函数、类型定义提供一些属性.<br><code>__attribute__</code>有很多属性deprecated、unused、cleanup等等， 本文主要讲 cleanup.<br><a id="more"></a><br>cleanup 变量作用域结束之前, 走 cleanup 方法.</p>
<p>基本功能:<br>变量作用域结束之前, 执行cleanup指定的方法,方法的参数为变量的地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-9139f7951f968b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-698d86c538b7a3cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面是, 当 block 作用域结束的时候让 cleanup 执行的具体实现.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static void cleanBlock(__strong void(^*block)(void))  &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if DEBUG</div><div class="line">#define keywordify autoreleasepool &#123;&#125;</div><div class="line">#else</div><div class="line">#define keywordify try &#123;&#125; @catch (...) &#123;&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">#define onExit \</div><div class="line">keywordify \</div><div class="line">__strong void(^block)(void) __attribute__((cleanup(cleanBlock), unused)) = ^</div></pre></td></tr></table></figure></p>
<p><code>keywordify</code> 的作用就是在使用的时候可以在前面加一个@, 可以防止 return-type warning, 使用<code>autoreleasepool</code>的时候会创建一个没有实际意义的自动释放池.<br>所以使用<code>@try/@catch/@finally</code>来实现前面加@.</p>
<p>具体可参考 ReactiveCocoa2.5 版本 “RACmetamacros.h”.</p>
<p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        NSLock *lock = [[NSLock alloc] init];</div><div class="line">        [lock lock];</div><div class="line">        @onExit &#123;</div><div class="line">            [lock unlock];</div><div class="line">            NSLog(@&quot;end&quot;);</div><div class="line">        &#125;;</div><div class="line">        sleep(5);</div><div class="line">        NSLog(@&quot;begin&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log:begin</div><div class="line">log:end</div></pre></td></tr></table></figure>
<p>onExit 主要的作用是在某个块执行结束, 自动执行 block, 避免了忘记 unlock.</p>
<p>如果想让代码在{}最后执行都可以使用 onExit.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 是一个编译命令, 可以为变量、函数、类型定义提供一些属性.&lt;br&gt;&lt;code&gt;__attribute__&lt;/code&gt;有很多属性deprecated、unused、cleanup等等， 本文主要讲 cleanup.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>objective-c 的消息转发</title>
    <link href="https://yansaid.github.io/2016/07/15/objective-c%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>https://yansaid.github.io/2016/07/15/objective-c消息转发/</id>
    <published>2016-07-14T16:00:00.000Z</published>
    <updated>2017-04-05T01:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>objc 在执行一个方法的时候是如何判断一个方法是否存在的?</p>
<a id="more"></a>
<ol>
<li>从本类和父类中查找.</li>
<li>检查是否动态添加方法.</li>
<li>查看是否存在快速消息转发.</li>
<li>查看标准消息转发.</li>
</ol>
<p>1-4是按照顺序进行的, 若在某个环节查到符合的方法, 下面的查找则终止.</p>
<ol>
<li>我就不具体解释了.</li>
<li><p>objc 是一门动态的语言, 它允许在运行时, 向一个类添加属性、方法等. class_addMethod、class_addIvar、class_addProperty、class_addProtocol. 具体使用就不介绍了. 需要重写 resolveInstanceMethod 方法, 在其中判断需要添加的方法, 使用class_addMethod来动态添加方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+(BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    if(aSEL == @selector(methodName))&#123;</div><div class="line">        class_addMethod(Class cls, SEL name, IMP imp,</div><div class="line">        const char *types) ;</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NSObject 提供快速消息转发方法, 只要重新</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>之后, 每次在父类本类中找不到, 并且没有找到动态添加方法, 则会走该方法, 你可以在这个方法中, return 目标对象, 则目标对象执行 aSelector. 如果没有重写标准消息转发, 并且 return nil, 则会报 <code>unrecognized selector sent to instance</code> 这个错误.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    Person *person = [[Person alloc]init];</div><div class="line">        if ([person respondsToSelector:aSelector]) &#123;</div><div class="line">        return person;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.标准消息转发, 主要可以实现多对象同时转发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 生成一个方法, 并存入表中</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    if (!signature) &#123;</div><div class="line">        signature = [yourObj methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    return signature; // 将一个新签名的方法放入表中</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现动态添加方法, 并执行方法</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    SEL seletor = [anInvocation selector];</div><div class="line">    if ([yourObj respondsToSelector:seletor]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:yourObj];</div><div class="line">    &#125;</div><div class="line">    // 这里可以转发若干个你想转发的对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方法的 invoke 大概应该是这样实现的</div><div class="line">// 相当于 class_addMethod, 将 yourObj 中的方法  IMP 给了[self class].</div><div class="line">- (void) invokeWithTarget:(id)target &#123;</div><div class="line">    Method method = class_getInstanceMethod([target class], aSelector);</div><div class="line">    class_addMethod([self class],</div><div class="line">    aSelector,</div><div class="line">    method_getImplementation(method),</div><div class="line">    method_getTypeEncoding(method));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;objc 在执行一个方法的时候是如何判断一个方法是否存在的?&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>一个react native 的第三方, 附 npm 发布教程.</title>
    <link href="https://yansaid.github.io/2016/06/30/tipsView/"/>
    <id>https://yansaid.github.io/2016/06/30/tipsView/</id>
    <published>2016-06-29T16:00:00.000Z</published>
    <updated>2017-05-09T04:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个我日常开发所使用的工具, 会在日后不断在 GitHub 上更新.<br>目前提供手写板的功能和截图的功能.<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/2131368-62683a0f099fd8d8.gif?imageMogr2/auto-orient/strip" alt=""><br>使用: npm i –save react-native-tipsview</p>
<p>具体使用请看demo: <a href="https://github.com/yansaid/RNTipsView/tree/master/Example" target="_blank" rel="external">https://github.com/yansaid/RNTipsView/tree/master/Example</a><br>运行 demo: 下载代码, 进入 Example/tips,<br>nmp install<br>进入 ios 工程直接运行项目即可, 目前仅支持 iOS.</p>
<p>npm 发布流程:</p>
<ol>
<li><p>首先注册npm 账号:<br><a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a>,免费的即可.</p>
</li>
<li><p>生成 package.json :<br>npm 上面的信息都包含在 package.json 文件中.<br>首先在控制台进入想要发布的 package 目录,<br>然后在控制台输入 npm init , 此时正在配置 package.json 文件.<br>配置信息包括很多.<br>name : 唯一标示, 必须全部为小写, npm i –save<code>react-native-tipsview</code>中, <code>react-native-tipsview</code>就是name.<br>version : 版本号.<br>description : 描述信息, 你查看发布后的包的描述就可以看见.<br>main : 入口文件.<br>keywords : 关键词, 主要用于搜索时.</p>
</li>
</ol>
<p>还有很多配置信息可自行搜索学习, 例如 GitHub 等等, 其中 name, 和 version 是必要字段, 没有则无法发布.</p>
<ol>
<li>发布<br><code>npm publish --registry http://registry.npmjs.org</code></li>
</ol>
<p>等待发布完毕, 可以尝试使用一下.</p>
<p>GitHub: <a href="https://github.com/yansaid/RNTipsView" target="_blank" rel="external">https://github.com/yansaid/RNTipsView</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个我日常开发所使用的工具, 会在日后不断在 GitHub 上更新.&lt;br&gt;目前提供手写板的功能和截图的功能.&lt;br&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://yansaid.github.io/categories/React-Native/"/>
    
    
      <category term="react native" scheme="https://yansaid.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>__strong、__weak、__block.</title>
    <link href="https://yansaid.github.io/2016/05/03/block/"/>
    <id>https://yansaid.github.io/2016/05/03/block/</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2017-04-14T02:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下循环引用, 为什么没用<code>__weak</code> 修饰就直接用 <code>self.</code>属性不会造成循环引用.<br>循环引用是指两个或者多个对象循环持有造成的无法释放.<br><a id="more"></a><br>类 <code>Person</code> 有个属性 <code>block</code>, 在 <code>block</code> 实现后, 此时 <code>self</code> 持有 <code>block</code>, 如果在 <code>block</code> 中, 直接使用 <code>self</code>, <code>block</code> 将持有 <code>self</code>, 造成循环引用, 如果 <code>block</code> 本身不是 <code>self</code> 的属性, 则 <code>self</code>不持有 <code>block</code>, 即使在 <code>block</code> 中直接使用 <code>self</code> 也不会造成循环引用, 但是为了避免多个对象的循环引用, 所以 <code>block</code> 中最好还是用<code>__weak</code>, 防止这种情况出现. 代理用 <code>weak</code> 与此同理.</p>
<p>__block:<br>使外部变量可以在 <code>Block</code> 内部进行修改.<br><img src="http://upload-images.jianshu.io/upload_images/2131368-4b64251e2b00e4a3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-d2d3f4e1e2394432?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>输出:<br>num:2, pointer:0xb000000000000022<br>blockNum:3, pointer:0xb000000000000032<br>可见 <strong> block 会拷贝原来对象,  </strong>block修饰的对象可被 Block 内外同时修改.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-2547ebf5885ccbef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可见 <code>doctor</code> 和 <code>self</code> 被 <code>block</code> 持有, 即使没有使用<code>__ block</code> 修饰,但他们的属性依然可以被修改, 不会像上面的 <code>num = @3;</code> 那样报错禁止修改, 和 <code>NSArray</code> 是一样的, <code>NSArray</code> 本身是不可修改的, 但是 NSArray 里面存放的对象依然是可以修改的.</p>
<p>__weak:<br><img src="http://upload-images.jianshu.io/upload_images/2131368-ed78fc9023d519ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2131368-b1c3b8f30a523dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>weak</code>的实现,  将当前对象(= 右边的对象)值的地址存入 <code>weak hash</code> 表, <code>hash</code> 表中的 <code>key</code> 是 <code>weak</code> 对象的地址, <code>value</code> 是当前对象(= 右边的对象)值的地址, 当每次访问<code>weak</code> 对象的时候, 首先找到 <code>key</code>, 再找到 <code>value</code>. 当当前对象的值被释放, <code>weak hash</code> 表将 <code>value</code> 设置为<code>nil</code>.  如果理解不了, 可以看一下 C语言的指针, 指针的指针. </p>
<p> __weak 的作用: <code>weak</code> 表中的指向的对象, 不计入引用计数. 不持有对象, 但可以引用对象, 不参与对象释放.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-188aa742ee71c5f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2131368-252e85de5c25330e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可见被<code>__weak</code> 修饰过的对象, 不会被 <code>block</code> 持有,所以在对象释放的时候, <code>block</code> 中的 <code>weak</code> 对象也被置为 <code>nil</code>.</p>
<p>但有一种特殊的情况,  就是存放在栈区的对象并不会因为引用对象的释放而释放.<br><img src="http://upload-images.jianshu.io/upload_images/2131368-5cb84159fe6dd19a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-b23a175a0bfa213a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>字符串常量是存在栈区的, 栈内存并不会动态释放, 而是当当前线程执行完毕后, 释放当前线程的栈内存. 所有的常量都存在栈区.<br>所以上面的例子中即使使用<code>__ weak</code> 修饰, 但是<code>@&quot;aa&quot;</code>这个常量并没有被释放, 所以 <code>weak</code>的地址指向依然存在值.</p>
<p><strong>strong:<br>在某个块内对当前对象引用计数加一.<br>在 AFN 中经常出现 <code>block</code> 外面 `</strong> weak<code>, 在内部再</code>__strong`.<br>这里有个例子需要理解</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-98d02c315523d276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="例 1"><br><img src="http://upload-images.jianshu.io/upload_images/2131368-0c334ec2de2f09c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个例子中, 在 <code>block</code> 里面已经通过<code>__strong</code> 对对象引用计数加一,但为什么置为 <code>doctor</code> 置为 <code>nil</code>, 就被释放掉了那?<br>再看下面的例子:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-ed9d6587642ae69e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="例 2"><br><img src="http://upload-images.jianshu.io/upload_images/2131368-3bb88da42b5adcf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个例子为什么只有 <code>doctor</code>是空那?<br>结合两个例子, 引用计数的改变是一个动态改变, 只有被强引用之后, 引用计数才会加一。</p>
<p>#####分析例 1：<br>在 <code>doctor</code> 置为 <code>nil</code> 之前, <code>block</code> 的<code>__ strong</code> 并没有执行, 所以当时 <code>doctor</code> 对象被当前的区块持有, 当 <code>doctor</code> 置为 <code>nil</code> 时, 该对象已经被释放, 所以 <code>__strong</code> 的时候, <code>weak</code> 地址的内存已经被释放, strong 指向 nil,  所以 doctor 对象引用计数并没有加 1.</p>
<p>#####分析例 2：<br>在 <code>doctor</code> 被置为<code>nil</code>之前执行<code>__ strong</code>, doctor 引用计数加 1,  对象被 <code>block</code> 持有,  执行 <code>doctor = nil</code> 之后, doctor 仍然被 <code>block</code> 持有.</p>
<p>说一下外面<code>__weak</code>,  里面<code>__strong</code>的好处, 在被<code>block</code>引用的时候,不会被 block 持有, 在<code>block</code>执行完毕, 立即将对象释放, 并不会造成循环引用, 而且还可以在多线程中, 在 <code>block</code> 区块内对对象持有.</p>
<p>这里有个概念就是区块持有和对象持有.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">     // 区块持有</div><div class="line">    // 在块内声明的变量, 在块执行完毕立即被释放.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对象持有: 地址指向内存.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先说一下循环引用, 为什么没用&lt;code&gt;__weak&lt;/code&gt; 修饰就直接用 &lt;code&gt;self.&lt;/code&gt;属性不会造成循环引用.&lt;br&gt;循环引用是指两个或者多个对象循环持有造成的无法释放.&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>类别（Category）添加weak （property）属性，关联（Associated）</title>
    <link href="https://yansaid.github.io/2016/03/21/%E7%B1%BB%E5%88%AB/"/>
    <id>https://yansaid.github.io/2016/03/21/类别/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2017-04-05T01:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Category 在平常代码中经常使用，在使用第三方工具时，遇到工具不能直接解决当前问题的情况，我就会使用到Category，通过给特定的类加一个方法来处理这种情况。<br>本文仅仅介绍给（Category）加 weak 属性。<br><a id="more"></a><br>weak：修饰OBJC对象，不会持有指向修饰对象，同样指向的对象引用计数就不会增加，当指向的对象被释放释放的时候，weak修饰的对象会被置为nil。<br>因为堆内存是动态的，所以当某个地址的对象被释放的时候，所有指向他的指针都应该被置为空。weak就是为了满足避免循环引用，同时在对象被释放的时候可以被置为空的情况而存在的。<br>assign是为了修饰栈内存中的数值对象，当使用assign修饰了一个OBJC对象的时候，可能造成野指针。原因在上面刚刚提到。</p>
<p>进入主题：给 Category 添加 weak 属性。<br>首先，给 Category 属性是需要使用runtime中的关联来实现set 和 get 方法。但runtime只提供如下几种修饰实现，并没有weak。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class="line">OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.</div><div class="line">*   The association is not made atomically. */</div><div class="line">OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.</div><div class="line">*   The association is not made atomically. */</div><div class="line">OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</div><div class="line">*   The association is made atomically. */</div><div class="line">OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</div><div class="line">*   The association is made atomically. */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>看了别人的思路之后，加以修改。runtime没有开放weak解决方案，所以只能模仿 weak 的思路来实现. 思路是这样的，让需要被 weak 修饰的对象去持有一个 strong 的对象，然后当被修饰的对象被释放的时候，持有的对象也会被释放，那么我们就可以捕捉到释放的事件，进而使用OBJC_ASSOCIATION_ASSIGN 来实现弱引用，在释放事件里面再将其释放掉，进而实现weak功能。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2131368-499f0c8db94c56fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 定义一个对象，使用block来回调析构函数。</div><div class="line">typedef void (^DeallocBlock)();</div><div class="line">@interface OriginalObject : NSObject</div><div class="line">@property (nonatomic, copy) DeallocBlock block;</div><div class="line">- (instancetype)initWithBlock:(DeallocBlock)block;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation OriginalObject</div><div class="line"></div><div class="line">- (instancetype)initWithBlock:(DeallocBlock)block</div><div class="line">&#123;</div><div class="line">self = [super init];</div><div class="line">if (self) &#123;</div><div class="line">self.block = block;</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line">- (void)dealloc &#123;</div><div class="line">self.block ? self.block() : nil;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Category添加属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// Category</div><div class="line">// NSObject+property.h</div><div class="line">@interface NSObject (property)</div><div class="line">@property (nonatomic, weak) id objc_weak_id;</div><div class="line">@end</div><div class="line"></div><div class="line">// NSObject+property.m</div><div class="line">@implementation NSObject (property)</div><div class="line">- (id)objc_weak_id &#123;</div><div class="line">return objc_getAssociatedObject(self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setObjc_weak_id:(id)objc_weak_id &#123;</div><div class="line">OriginalObject *ob = [[OriginalObject alloc] initWithBlock:^&#123;</div><div class="line">objc_setAssociatedObject(self, @selector(objc_weak_id), nil, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">&#125;];</div><div class="line">// 这里关联的key必须唯一，如果使用_cmd，对一个对象多次关联的时候，前面的对象关联会失效。</div><div class="line">// 给需要被 assign 修饰的对象添加一个 strong 对象.</div><div class="line">objc_setAssociatedObject(objc_weak_id, (__bridge const void *)(ob.block), ob, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">objc_setAssociatedObject(self, @selector(objc_weak_id), objc_weak_id, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tips: 一个不被持有的对象是不能被 weak 指向. 即,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">A *a = [[A alloc] init];</div><div class="line">self.weakObj = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样写是不成立的, a 会在{}执行之后便释放掉, self.weakObj 指向 nil. 所以上面 objc_weak_id 要关联一个 retain 的对象.</p>
<p>具体体验weak 和 assgin的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,weak) id      weakPoint;</div><div class="line">@property (nonatomic,assign) id    assignPoint;</div><div class="line">@property (nonatomic,strong) id    strongPoint;</div><div class="line"></div><div class="line">self.strongPoint = [NSDate date];</div><div class="line">self.weakPoint = self.strongPoint;</div><div class="line">self.assignPoint = self.strongPoint;</div><div class="line">self.strongPoint = nil;</div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 0x0 指针置为空。</div><div class="line">NSLog(@&quot;%p&quot;, self.assignPoint); // crash 因为self.assignPoint指针指向的对象已经被释放。</div></pre></td></tr></table></figure></p>
<p>测试weak是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self.strongPoint = [NSDate date];</div><div class="line">self.objc_weak_id = self.strongPoint;</div><div class="line">self.weakPoint = self.strongPoint;</div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 指针。</div><div class="line">NSLog(@&quot;%p&quot;, self.objc_weak_id); // print 相同的指针。</div><div class="line">self.strongPoint = nil;</div><div class="line"></div><div class="line">NSLog(@&quot;%p&quot;, self.weakPoint); // print 0x0 指针置为空。</div><div class="line">NSLog(@&quot;%p&quot;, self.objc_weak_id); // print 0x0 指针置为空。</div></pre></td></tr></table></figure></p>
<p>在Category中添加 property 相对添加方法少一些，而添加weak property是少之又少，但实现 通过这次实践，你可以明白什么是weak，什么是assign，而不是仅仅知道delegate中用weak，NSInteger用assign。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Category 在平常代码中经常使用，在使用第三方工具时，遇到工具不能直接解决当前问题的情况，我就会使用到Category，通过给特定的类加一个方法来处理这种情况。&lt;br&gt;本文仅仅介绍给（Category）加 weak 属性。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://yansaid.github.io/categories/iOS/"/>
    
    
      <category term="ios" scheme="https://yansaid.github.io/tags/ios/"/>
    
  </entry>
  
</feed>
